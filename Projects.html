<!DOCTYPE html>
<!--********************************************-->
<!--*       Generated from PreTeXt source      *-->
<!--*       on 2024-06-19T12:52:55-03:00       *-->
<!--*   A recent stable commit (2020-08-09):   *-->
<!--* 98f21740783f166a773df4dc83cab5293ab63a4a *-->
<!--*                                          *-->
<!--*         https://pretextbook.org          *-->
<!--*                                          *-->
<!--********************************************-->
<html lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>Projetos</title>
<meta name="Keywords" content="Authored in PreTeXt">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<script src="https://sagecell.sagemath.org/embedded_sagecell.js"></script><script>window.MathJax = {
  tex: {
    inlineMath: [['\\(','\\)']],
    tags: "none",
    useLabelIds: true,
    tagSide: "right",
    tagIndent: ".8em",
    packages: {'[+]': ['base', 'extpfeil', 'ams', 'amscd', 'newcommand', 'knowl']}
  },
  options: {
    ignoreHtmlClass: "tex2jax_ignore",
    processHtmlClass: "has_am",
    renderActions: {
        findScript: [10, function (doc) {
            document.querySelectorAll('script[type^="math/tex"]').forEach(function(node) {
                var display = !!node.type.match(/; *mode=display/);
                var math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
                var text = document.createTextNode('');
                node.parentNode.replaceChild(text, node);
                math.start = {node: text, delim: '', n: 0};
                math.end = {node: text, delim: '', n: 0};
                doc.math.push(math);
            });
        }, '']
    },
  },
  chtml: {
    scale: 0.88,
    mtextInheritFont: true
  },
  loader: {
    load: ['input/asciimath', '[tex]/extpfeil', '[tex]/amscd', '[tex]/newcommand', '[pretext]/mathjaxknowl3.js'],
    paths: {pretext: "https://pretextbook.org/js/lib"},
  },
};
</script><script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"></script><script>$(function () {
    // Make *any* div with class 'sagecell-sage' an executable Sage cell
    // Their results will be linked, only within language type
    sagecell.makeSagecell({inputLocation: 'div.sagecell-sage',
                           linked: true,
                           languages: ['sage'],
                           evalButtonText: 'Evaluate (Python)'});
});
</script><script xmlns:svg="http://www.w3.org/2000/svg" src="https://pretextbook.org/js/lib/jquery.min.js"></script><script xmlns:svg="http://www.w3.org/2000/svg" src="https://pretextbook.org/js/lib/jquery.sticky.js"></script><script xmlns:svg="http://www.w3.org/2000/svg" src="https://pretextbook.org/js/lib/jquery.espy.min.js"></script><script xmlns:svg="http://www.w3.org/2000/svg" src="https://pretextbook.org/js/0.13/pretext.js"></script><script xmlns:svg="http://www.w3.org/2000/svg" src="https://pretextbook.org/js/0.13/pretext_add_on.js"></script><script xmlns:svg="http://www.w3.org/2000/svg" src="https://pretextbook.org/js/lib/knowl.js"></script><!--knowl.js code controls Sage Cells within knowls--><script xmlns:svg="http://www.w3.org/2000/svg">sagecellEvalName='Evaluate (Sage)';
</script><link xmlns:svg="http://www.w3.org/2000/svg" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400italic,600,600italic" rel="stylesheet" type="text/css">
<link xmlns:svg="http://www.w3.org/2000/svg" href="https://fonts.googleapis.com/css?family=Inconsolata:400,700&amp;subset=latin,latin-ext" rel="stylesheet" type="text/css">
<link xmlns:svg="http://www.w3.org/2000/svg" href="https://pretextbook.org/css/0.31/pretext.css" rel="stylesheet" type="text/css">
<link xmlns:svg="http://www.w3.org/2000/svg" href="https://pretextbook.org/css/0.31/pretext_add_on.css" rel="stylesheet" type="text/css">
<link xmlns:svg="http://www.w3.org/2000/svg" href="https://pretextbook.org/css/0.31/banner_default.css" rel="stylesheet" type="text/css">
<link xmlns:svg="http://www.w3.org/2000/svg" href="https://pretextbook.org/css/0.31/toc_default.css" rel="stylesheet" type="text/css">
<link xmlns:svg="http://www.w3.org/2000/svg" href="https://pretextbook.org/css/0.31/knowls_default.css" rel="stylesheet" type="text/css">
<link xmlns:svg="http://www.w3.org/2000/svg" href="https://pretextbook.org/css/0.31/style_default.css" rel="stylesheet" type="text/css">
<link xmlns:svg="http://www.w3.org/2000/svg" href="https://pretextbook.org/css/0.31/colors_default.css" rel="stylesheet" type="text/css">
<link xmlns:svg="http://www.w3.org/2000/svg" href="https://pretextbook.org/css/0.31/setcolors.css" rel="stylesheet" type="text/css">
<!-- 2019-10-12: Temporary - CSS file for experiments with styling --><link xmlns:svg="http://www.w3.org/2000/svg" href="developer.css" rel="stylesheet" type="text/css">
</head>
<body class="pretext-article has-toc has-sidebar-left">
<a class="assistive" href="#content">Skip to main content</a><div xmlns:svg="http://www.w3.org/2000/svg" id="latex-macros" class="hidden-content" style="display:none">\(\newcommand{\doubler}[1]{2#1}
\newcommand{\lt}{&lt;}
\newcommand{\gt}{&gt;}
\newcommand{\amp}{&amp;}
\)</div>
<header id="masthead" class="smallbuttons"><div class="banner"><div class="container">
<a id="logo-link" href=""></a><div class="title-container">
<h1 class="heading"><a href="minimal.html"><span class="title">Álgebra Linear com python</span></a></h1>
<p class="byline">Márcio Rostirolla Adames</p>
</div>
</div></div>
<nav xmlns:svg="http://www.w3.org/2000/svg" id="primary-navbar" class="navbar"><div class="container">
<div class="navbar-top-buttons">
<button class="sidebar-left-toggle-button button active" aria-label="Show or hide table of contents sidebar">Contents</button><div class="tree-nav toolbar toolbar-divisor-3"><span class="threebuttons"><a id="previousbutton" class="previous-button toolbar-item button" href="Matrices.html" title="Previous">Prev</a><a id="upbutton" class="up-button button toolbar-item" href="minimal.html" title="Up">Up</a><a id="nextbutton" class="next-button button toolbar-item" href="espacos-vetoriais.html" title="Next">Next</a></span></div>
</div>
<div class="navbar-bottom-buttons toolbar toolbar-divisor-4">
<button class="sidebar-left-toggle-button button toolbar-item active">Contents</button><a class="previous-button toolbar-item button" href="Matrices.html" title="Previous">Prev</a><a class="up-button button toolbar-item" href="minimal.html" title="Up">Up</a><a class="next-button button toolbar-item" href="espacos-vetoriais.html" title="Next">Next</a>
</div>
</div></nav></header><div class="page">
<div xmlns:svg="http://www.w3.org/2000/svg" id="sidebar-left" class="sidebar" role="navigation"><div class="sidebar-content">
<nav id="toc"><ul>
<li class="link frontmatter"><a href="frontmatter-1.html" data-scroll="frontmatter-1"><span class="title">Front Matter</span></a></li>
<li class="link">
<a href="sistemas-lineares.html" data-scroll="sistemas-lineares"><span class="codenumber">1</span> <span class="title">Sistemas de Equações Lineares</span></a><ul>
<li><a href="sistemas-lineares.html#sis-lin-sub" data-scroll="sis-lin-sub">Sistemas Lineares</a></li>
<li><a href="sistemas-lineares.html#matrix-sis-lin" data-scroll="matrix-sis-lin">Matrizes representando sistemas lineares</a></li>
<li><a href="sistemas-lineares.html#Gauss-Jordan-red" data-scroll="Gauss-Jordan-red">Redução de Gauss Jordan</a></li>
</ul>
</li>
<li class="link">
<a href="Matrices.html" data-scroll="Matrices"><span class="codenumber">2</span> <span class="title">Matrizes</span></a><ul>
<li><a href="Matrices.html#matrizes_operacoes" data-scroll="matrizes_operacoes">Matrizes e operações</a></li>
<li><a href="Matrices.html#Matrix_rep_mult" data-scroll="Matrix_rep_mult">Representação Matricial e Multiplicação de Matrizes</a></li>
<li><a href="Matrices.html#matrix_mult_meaning" data-scroll="matrix_mult_meaning">Matrizes elementares</a></li>
<li><a href="Matrices.html#determinants" data-scroll="determinants">Determinantes</a></li>
<li><a href="Matrices.html#Coding_message" data-scroll="Coding_message">Aplicação: mensagens codificadas</a></li>
<li><a href="Matrices.html#subsection-9" data-scroll="subsection-9">Decomposição LU</a></li>
</ul>
</li>
<li class="link active">
<a href="Projects.html" data-scroll="Projects"><span class="codenumber">3</span> <span class="title">Projetos</span></a><ul>
<li><a href="Projects.html#Proj1" data-scroll="Proj1">Projeto 1 - Criando uma dieta</a></li>
<li><a href="Projects.html#Proj2" data-scroll="Proj2">Projeto 2 - Análise de circuitos resistivos</a></li>
<li><a href="Projects.html#Proj3" data-scroll="Proj3">Projeto 3 - Ajustando dados aleatórios</a></li>
<li><a href="Projects.html#Proj4" data-scroll="Proj4">Projeto 4 - Metrologia coordenada</a></li>
<li><a href="Projects.html#Proj5" data-scroll="Proj5">Projeto 5 - Compressão de imagens quadradas com autovalores e autovetores</a></li>
<li><a href="Projects.html#Proj6" data-scroll="Proj6">Projeto 6 - Compressão de imagens retangulares utilizando SVD</a></li>
</ul>
</li>
<li class="link">
<a href="espacos-vetoriais.html" data-scroll="espacos-vetoriais"><span class="codenumber">4</span> <span class="title">Espaços Vetoriais</span></a><ul>
<li><a href="espacos-vetoriais.html#Rn_vecs" data-scroll="Rn_vecs">Vetores em \(\mathbb{R}^n\)</a></li>
<li><a href="espacos-vetoriais.html#Esp_vet" data-scroll="Esp_vet">Espaços Vetoriais</a></li>
</ul>
</li>
<li class="link">
<a href="subescos.html" data-scroll="subescos"><span class="codenumber">5</span> <span class="title">Subespaços Vetoriais</span></a><ul>
<li><a href="subescos.html#subespacos-subsection" data-scroll="subespacos-subsection">Subespaço</a></li>
<li><a href="subescos.html#Esp_nulo" data-scroll="Esp_nulo">Espaço Nulo de uma matriz</a></li>
</ul>
</li>
<li class="link">
<a href="bases.html" data-scroll="bases"><span class="codenumber">6</span> <span class="title">Base de um Espaço Vetorial</span></a><ul>
<li><a href="bases.html#coberturas" data-scroll="coberturas">Spans (Coberturas)</a></li>
<li><a href="bases.html#dependencia_linear" data-scroll="dependencia_linear">Dependência Linear</a></li>
<li><a href="bases.html#bases_subsection" data-scroll="bases_subsection">Bases</a></li>
<li><a href="bases.html#mudanca_base" data-scroll="mudanca_base">Mudança de base</a></li>
<li><a href="bases.html#esp_linha" data-scroll="esp_linha">Espaço Linha e Espaço Coluna</a></li>
</ul>
</li>
<li class="link">
<a href="produto_interno.html" data-scroll="produto_interno"><span class="codenumber">7</span> <span class="title">Produto interno e ortogonalidade em \(\mathbb{R}^n\text{.}\)</span></a><ul>
<li><a href="produto_interno.html#inner_prod" data-scroll="inner_prod">Produto Interno (ou escalar) em \(\mathbb{R}^n\)</a></li>
<li><a href="produto_interno.html#projecoes" data-scroll="projecoes">Projeções escalares e vetoriais</a></li>
<li><a href="produto_interno.html#Gram-Schmidt" data-scroll="Gram-Schmidt">Conjuntos ortogonais e ortogonalização de Gram-Schmidt</a></li>
</ul>
</li>
<li class="link">
<a href="Transformacoes_lineares.html" data-scroll="Transformacoes_lineares"><span class="codenumber">8</span> <span class="title">Transformações Lineares</span></a><ul>
<li><a href="Transformacoes_lineares.html#trans_lin" data-scroll="trans_lin">Transformações Lineares</a></li>
<li><a href="Transformacoes_lineares.html#matriz_lin_trans" data-scroll="matriz_lin_trans">Representação Matricial de Transformações Lineares</a></li>
<li><a href="Transformacoes_lineares.html#trans_lineares_prob" data-scroll="trans_lineares_prob">Problemas envolvendo transformações Lineares</a></li>
</ul>
</li>
<li class="link">
<a href="auto_val.html" data-scroll="auto_val"><span class="codenumber">9</span> <span class="title">Autovalores e autovetores</span></a><ul>
<li><a href="auto_val.html#auto_val_sub" data-scroll="auto_val_sub">Autovalores e autovetores</a></li>
<li><a href="auto_val.html#autoval_teormas" data-scroll="autoval_teormas">Resultados e dificuldades relacionados a autovetores e autovalores.</a></li>
<li><a href="auto_val.html#aplicacoes" data-scroll="aplicacoes">Aplicações: sistemas de EDOs lineares de primeira ordem.</a></li>
<li><a href="auto_val.html#aplicacoes_2" data-scroll="aplicacoes_2">Aplicações: sistemas de EDOs lineares de segunda ordem.</a></li>
</ul>
</li>
</ul></nav><div class="extras"><nav><a class="pretext-link" href="https://pretextbook.org">Authored in PreTeXt</a><a href="https://www.mathjax.org"><img title="Powered by MathJax" src="https://www.mathjax.org/badge/badge.gif" alt="Powered by MathJax"></a></nav></div>
</div></div>
<main class="main"><div id="content" class="pretext-content"><section xmlns:svg="http://www.w3.org/2000/svg" class="section" id="Projects"><h2 class="heading hide-type">
<span class="type">Section</span> <span class="codenumber">3</span> <span class="title">Projetos</span>
</h2>
<p id="p-155">Essa seção reúne projetos utilizando álgebra linear. ** Em construção**</p>
<section class="subsection" id="Proj1"><h3 class="heading hide-type">
<span class="type">Subsection</span> <span class="codenumber">3.1</span> <span class="title">Projeto 1 - Criando uma dieta</span>
</h3>
<p id="p-156">Imagine que você é um nutricionista, e precisa prescrever uma dieta para um paciente. Você pode optar por alimentos em uma lista fechada. Os valores nutricionais desses alimentos são conhecidos, e você deve determinar a quantidade de cada alimento a ser consumida diariamente, de modo que, ao fim do dia, o paciente consuma determinada quantidade de cada macronutriente ou substância química presente nos alimentos, como por exemplo gorduras, carboidratos, minerais, proteínas, dentre outros.</p>
<article class="exercise exercise-like" id="exercise-33"><a data-knowl="" class="id-ref exercise-knowl original" data-refid="hk-exercise-33"><h6 class="heading">
<span class="type">Checkpoint</span><span class="space"> </span><span class="codenumber">3.1</span><span class="period">.</span>
</h6></a></article><div class="hidden-content tex2jax_ignore" id="hk-exercise-33"><article class="exercise exercise-like"><p id="p-157">Encontre as quantides de fibra alimentar, carboidratos, sódio, proteínas e gorduras totais de 5 alimentos de sua escolha. Para isso, utilize o site <a class="external" href="https://tabnut.dis.epm.br/alimento" target="_blank">https://tabnut.dis.epm.br/alimento</a></p>
<a data-knowl="" class="id-ref solution-knowl original" data-refid="hk-solution-1" id="solution-1"><span class="type">Solution.</span> </a><div class="hidden-content tex2jax_ignore" id="hk-solution-1"><div class="solution solution-like">Exemplo de solução (seus alimentos serão, provavelmente, diferentes): <ol class="decimal">
<li id="li-92"><p id="p-derived-li-92">Arroz, branco, grao longo, normal, cozido</p></li>
<li id="li-93"><p id="p-derived-li-93">Feijao, preto, semente madura, cozido, sem sal</p></li>
<li id="li-94"><p id="p-derived-li-94">Frango, carne branca, so carne, pronto para consumo, assado</p></li>
<li id="li-95"><p id="p-derived-li-95">Alface, crespa, crua</p></li>
<li id="li-96"><p id="p-derived-li-96">Tomate, vermelho, maduro, cru</p></li>
</ol>
<ol class="decimal"></ol> Obs: As quantidades informadas se referem a uma porção de 100 gramas do alimento mencionado. <figure class="table table-like" id="table-1"><figcaption><span class="type">Table</span><span class="space"> </span><span class="codenumber">3.2<span class="period">.</span></span><span class="space"> </span></figcaption><div class="tabular-box natural-width"><table class="tabular">
<tr>
<td class="c m b0 r0 l0 t0 lines">Alimento</td>
<td class="l m b0 r0 l0 t0 lines">Fibra</td>
<td class="l m b0 r0 l0 t0 lines">Carboidratos</td>
<td class="l m b0 r0 l0 t0 lines">Sódio</td>
<td class="l m b0 r0 l0 t0 lines">Proteínas</td>
<td class="l m b0 r0 l0 t0 lines">Gorduras</td>
</tr>
<tr>
<td class="l m b0 r0 l0 t0 lines">1</td>
<td class="l m b0 r0 l0 t0 lines">0,4 g</td>
<td class="l m b0 r0 l0 t0 lines">28,17 g</td>
<td class="l m b0 r0 l0 t0 lines">1 mg</td>
<td class="l m b0 r0 l0 t0 lines">2,69 g</td>
<td class="l m b0 r0 l0 t0 lines">0,28 g</td>
</tr>
<tr>
<td class="l m b0 r0 l0 t0 lines">2</td>
<td class="l m b0 r0 l0 t0 lines">8,7 g</td>
<td class="l m b0 r0 l0 t0 lines">23,71 g</td>
<td class="l m b0 r0 l0 t0 lines">1 mg</td>
<td class="l m b0 r0 l0 t0 lines">8,86 g</td>
<td class="l m b0 r0 l0 t0 lines">0,54 g</td>
</tr>
<tr>
<td class="l m b0 r0 l0 t0 lines">3</td>
<td class="l m b0 r0 l0 t0 lines">0 g</td>
<td class="l m b0 r0 l0 t0 lines">0 g</td>
<td class="l m b0 r0 l0 t0 lines">51 mg</td>
<td class="l m b0 r0 l0 t0 lines">27,13 g</td>
<td class="l m b0 r0 l0 t0 lines">4,07 g</td>
</tr>
<tr>
<td class="l m b0 r0 l0 t0 lines">4</td>
<td class="l m b0 r0 l0 t0 lines">1,2 g</td>
<td class="l m b0 r0 l0 t0 lines">2,97 g</td>
<td class="l m b0 r0 l0 t0 lines">10 mg</td>
<td class="l m b0 r0 l0 t0 lines">0,9 g</td>
<td class="l m b0 r0 l0 t0 lines">0,14 g</td>
</tr>
<tr>
<td class="l m b0 r0 l0 t0 lines">5</td>
<td class="l m b0 r0 l0 t0 lines">1,2 g</td>
<td class="l m b0 r0 l0 t0 lines">3,89 g</td>
<td class="l m b0 r0 l0 t0 lines">5 mg</td>
<td class="l m b0 r0 l0 t0 lines">0,88 g</td>
<td class="l m b0 r0 l0 t0 lines">0,2 g</td>
</tr>
</table></div></figure>
</div></div></article></div>
<article class="exercise exercise-like" id="exercise-34"><a data-knowl="" class="id-ref exercise-knowl original" data-refid="hk-exercise-34"><h6 class="heading">
<span class="type">Checkpoint</span><span class="space"> </span><span class="codenumber">3.3</span><span class="period">.</span>
</h6></a></article><div class="hidden-content tex2jax_ignore" id="hk-exercise-34"><article class="exercise exercise-like"><p id="p-158">Determine uma quantidade-alvo para cada macronutriente citado e escreva um sistema linear que modele a dieta proposta.</p>
<a data-knowl="" class="id-ref solution-knowl original" data-refid="hk-solution-2" id="solution-2"><span class="type">Solution.</span> </a><div class="hidden-content tex2jax_ignore" id="hk-solution-2"><div class="solution solution-like">Um exemplo de solução, utilizando os alimentos citados anteriormente, é: <ol class="decimal">
<li id="li-97"><p id="p-derived-li-97">Fibra alimentar: 20.6 g</p></li>
<li id="li-98"><p id="p-derived-li-98">Carboidratos: 110.62 g</p></li>
<li id="li-99"><p id="p-derived-li-99">Sódio: 172 mg</p></li>
<li id="li-100"><p id="p-derived-li-100">Proteínas: 106.27 g</p></li>
<li id="li-101"><p id="p-derived-li-101">Gorduras: 14.19 g</p></li>
</ol>
<div class="displaymath">
\begin{align*}
\amp 0,4\, x_1 + 8,7\, x_2 + 1,2\, x_4 + 1,2\, x_5 = 20,6 \\
\amp 28,17\, x_1 + 23,71\,x_2 + 2,97\, x_4 + 3,89\, x_5 = 110,62\\
\amp x_1 + x_2 + 51\, x_3 + 10\, x_4 + 5\, x_5 = 172\\
\amp 2,69\, x_1 + 8,86\, x_2 + 27,13\, x_3 + 0,9\, x_4 + 0,88\, x_5 = 106,27\\
\amp 0,28\, x_1 + 0,54\, x_2 + 4,07\, x_3 + 0,14\, x_4 + 0,2\, x_5 = 14,19
\end{align*}
</div>
</div></div></article></div>
<article class="exercise exercise-like" id="exercise-35"><a data-knowl="" class="id-ref exercise-knowl original" data-refid="hk-exercise-35"><h6 class="heading">
<span class="type">Checkpoint</span><span class="space"> </span><span class="codenumber">3.4</span><span class="period">.</span>
</h6></a></article><div class="hidden-content tex2jax_ignore" id="hk-exercise-35"><article class="exercise exercise-like"><p id="p-159">Utilize o código na <a class="xref" data-knowl="./knowl/sol_lin_sys.html" title="Remark 3.5">Remark 3.5</a>  para resolver o sistema linear e descobrir as quantidades de cada alimento que o paciente deve consumir.</p>
<a data-knowl="" class="id-ref solution-knowl original" data-refid="hk-solution-3" id="solution-3"><span class="type">Solution.</span> </a><div class="hidden-content tex2jax_ignore" id="hk-solution-3"><div class="solution solution-like">Para o exemplo anterior, a solução devolvida pelo programa foi: <ol class="decimal"></ol> Você deverá consumir diariamente: <ul class="disc">
<li id="li-102"><p id="p-derived-li-102">200.0 g de Arroz</p></li>
<li id="li-103"><p id="p-derived-li-103">200.0 g de Feijão</p></li>
<li id="li-104"><p id="p-derived-li-104">300.0 g de Frango</p></li>
<li id="li-105"><p id="p-derived-li-105">100.0 g de Alface</p></li>
<li id="li-106"><p id="p-derived-li-106">100.0 g de Tomate</p></li>
</ul>
</div></div></article></div>
<article class="remark remark-like" id="sol_lin_sys"><h6 class="heading">
<span class="type">Remark</span><span class="space"> </span><span class="codenumber">3.5</span><span class="period">.</span>
</h6>
<p id="p-160">Código para a resolução de sistemas lineares utilizando o método de Gauss-Jordan.</p>
<div class="sagecell-sage" id="sage-26"><script type="text/x-sage">import numpy as np
import fractions

# Aqui estão os rótulos do problema
und = "g"  # Unidade de massa
foods = ["Arroz", "Feijão", "Frango", "Alface", "Tomate"]  # Lista de alimentos (Em ordem)
quant = 100  # A cada quantos gramas/quilos/etc de comida temos a quantidade listada de nutrientes?
negSol = True  # Caso esteja setado como "False", o programa gerará um erro caso as soluções sejam negativas

# Esta variável define o número de casas decimais para arredondamento dos resultados
decPlaces = 2

# Coloque aqui a matriz AMPLIADA do sistema:
ampl = [[   0.4,    8.7,     0,   1.2,   1.2,    20.6],
        [ 28.17,  23.71,     0,  2.97,  3.89,  110.62],
        [     1,      1,    51,    10,     5,     172],
        [  2.69,   8.86, 27.13,   0.9,  0.88,  106.27],
        [  0.28,   0.54,  4.07,  0.14,   0.2,   14.19]]

# Estes códigos são referentes às funções que realizam a redução de Gauss-Jordan

def gaussianElimination(A,prin=True):
    a=0
    A = A + fractions.Fraction()

    if prin==True:
        print('A='+str(A))
    for j in range(np.shape(A)[1]-1):
        b=0
        for i in range(a,np.shape(A)[0]):
            if A[i,j] != 0:
                if a !=i:
                    A[[a,i]]=A[[i,a]]
                    if prin==True:
                        print('\n~'+str(A))
                if A[a,j]!=1:
                    A[a]=A[a]/A[a,j]
                    if prin==True:
                        print('\n~'+str(A))
                a=a+1
                b=1
                break
        if b==1:
            for i in range(a,np.shape(A)[0]):
                if A[i,j] != 0:
                    A[i]=A[i]-A[a-1]*A[i,j]
                if prin==True:
                    print('\n~'+str(A))

        i = 0
        for line in A:
            j = 0
            for elem in line:
                A[i][j] = float(elem)
                j += 1
            i += 1

    np.set_printoptions(formatter={'all':lambda x: str(fractions.Fraction(x).limit_denominator())})
    return A

def gaussJordan(A,prin=True):
    B=gaussianElimination(A,prin)
    #print('jordan')
    a=0
    for i in range(np.shape(A)[0]):
        b=0
        for j in range(np.shape(A)[1]):
            if B[np.shape(B)[0]-i-1,j] == 1 and b==0:
                b=j
                for k in range(np.shape(B)[0]-i-1):
                    B[np.shape(B)[0]-i-2-k]=B[np.shape(B)[0]-i-2-k]- B[np.shape(B)[0]-i-2-k,j]*B[B.shape[0]-i-1]
                    if prin==True:
                            print('\n~'+str(B))                
    np.set_printoptions(formatter={'all':lambda x: str(fractions.Fraction(x).limit_denominator())})
    return B

ampl = np.array(ampl)
done = False

# Dimensões da matriz de coeficientes A
m = np.shape(ampl)[0]
n = np.shape(ampl)[1] - 1

# Extraindo a matriz de coeficientes da matriz ampliada
A = ampl[0:m, 0:n]
A = np.array(A)

# Agora iremos verificar em qual caso o sistema se encaixa: Solução única, sem solução ou infinitas soluções
# Para isso, verificaremos o posto da matriz de coeficientes A e o posto da matriz ampliada
rankA = np.linalg.matrix_rank(A)
rankAmpl = np.linalg.matrix_rank(ampl)

# Para resolver o sistema linear, será feita a redução de Gauss-Jordan na matriz ampliada:
print("Escalonamento passo a passo da matriz ampliada do sistema:\n")
esc = gaussJordan(ampl)

# Devido ao truncamento em python, vamos filtrar valores infinitesimais para evitar que fiquem como "-0.0"
i = 0
changed = False
while i < m:
    if round(esc[i][n], decPlaces) == -0.0:
        esc[i][n] = 0
        changed = True
    i+=1

if changed == True:
    esc = gaussJordan(esc, prin=False)

# Imprimindo na tela a matriz ampliada escalonada reduzida
print("\nMatriz ampliada escalonada reduzida do sistema:")
print(esc, "\n")

# Aqui verificamos se o sistema é sem solução. De acordo com o teorema, se o posto da matriz ampliada
# for diferente do posto da matriz de coeficientes, o sistema não tem solução
if rankA != rankAmpl:
    raise Exception("O sistema não possui soluções reais!")

# Aqui verificamos se o sistema é de solução única
sol = []
if rankA == n:
    for i in range(rankA):
        sol.append((esc[i][n])*quant)

    # Aqui filtramos os valores: Valores negativos não fazem sentido nesse contexto
    if negSol == False:
        for elem in sol:
            if elem < 0:
                raise Exception("O sistema linear possui solução negativa")

    # Aqui vamos imprimir os resultados de maneira formatada
    print("Você deverá consumir diariamente:")
    for i in range(n):
        print(f'{round(sol[i], decPlaces)} {und} de {foods[i]}')
    done = True

# Se a execução do programa chegar até aqui, temos várias soluções.
# Iremos trabalhar com otimização linear para interpretar os resultados.

if not done:
    # inicialização de contadores
    i = 0
    j = 0

    # Array que contem as linhas com as variaveis fixas
    fixas = []
    # Array que contem as variáveis fixas
    varsFixas = []
    # Array com as linhas que contém variáveis livres
    livres = []

    while i < rankA:
        livres.append(i)
        i += 1

    # Aqui filtramos valores negativos:
    if negSol == False:
        for line in esc:
            if line[n] < 0:
                raise Exception("O sistema linear possui solução negativa")


    # Aqui verificaremos as linhas da matriz escalonada reduzida em busca
    # de linhas que possuam apenas um número não nulo, em busca de variáveis
    # cujo valor seja fixado

    i = 0
    while i < rankA:
        notNullCount = 0
        j = 0
        while j < n:
            if esc[i][j] != 0:
                notNullCount += 1
                k = j
            j += 1
        if notNullCount == 1:
            livres.remove(i)
            varsFixas.append(k)
            fixas.append(i)
        i += 1


    # Já sabendo as relações entre variáveis fixas e livres, vamos imprimir
    # na tela os resultados (por ora, sem otimização)

    print("Você deverá consumir diariamente:")
    for i in fixas:
            print(f'{round(esc[i][n]*quant, decPlaces)} {und} de {foods[varsFixas[i]]}')

    for i in livres:
        varsLivres = []
        j = 0
        while j < n:
            if esc[i][j] != 0:
                varsLivres.append(j)
                k=j
            j += 1

        print("Você pode escolher consumir diariamente:")
        for j in range(len(varsLivres) - 1):
            print(f'{foods[varsLivres[j]]},', end=" ")
        print(f'{foods[k]},', end=" ")
        print(f'De modo que:')
        for j in range(len(varsLivres) - 1):
            print(f'{esc[i][varsLivres[j]]} porção de {foods[varsLivres[j]]} +', end=" ")
        print(f'{esc[i][k]} porção de {foods[k]} totalize {round(esc[i][n]*quant, decPlaces)}{und}')
</script></div></article><article class="exercise exercise-like" id="exercise-36"><a data-knowl="" class="id-ref exercise-knowl original" data-refid="hk-exercise-36"><h6 class="heading">
<span class="type">Checkpoint</span><span class="space"> </span><span class="codenumber">3.6</span><span class="period">.</span>
</h6></a></article><div class="hidden-content tex2jax_ignore" id="hk-exercise-36"><article class="exercise exercise-like"><p id="p-161">A solução encontrada faz sentido? Há algo inconveniente ou inadequado na solução? Justifique sua resposta.</p>
<a data-knowl="" class="id-ref solution-knowl original" data-refid="hk-solution-4" id="solution-4"><span class="type">Solution.</span> </a><div class="hidden-content tex2jax_ignore" id="hk-solution-4"><div class="solution solution-like">Reflita se, dentro do contexto da dieta, sua solução faz sentido. Nesse contexto, fazem sentido soluções negativas? Mude o parâmetro "negSol" do código em <a class="xref" data-knowl="./knowl/sol_lin_sys.html" title="Remark 3.5">Remark 3.5</a> para "False". O programa irá bloquear automaticamente qualquer solução negativa que aparecer!</div></div></article></div>
<article class="exercise exercise-like" id="exercise-37"><a data-knowl="" class="id-ref exercise-knowl original" data-refid="hk-exercise-37"><h6 class="heading">
<span class="type">Checkpoint</span><span class="space"> </span><span class="codenumber">3.7</span><span class="period">.</span>
</h6></a></article><div class="hidden-content tex2jax_ignore" id="hk-exercise-37"><article class="exercise exercise-like"><p id="p-162">Remova um dos alimentos de sua lista e tente determinar as quantidedes ideais de cada alimento para atingir seus objetivos nutricionais. Qual o resulta obtido? O que você acha que ocorreu?</p>
<a data-knowl="" class="id-ref solution-knowl original" data-refid="hk-solution-5" id="solution-5"><span class="type">Solution.</span> </a><div class="hidden-content tex2jax_ignore" id="hk-solution-5"><div class="solution solution-like">Existem mais equações que variáveis, logo, o sistema não possui soluções reais.</div></div></article></div>
<article class="exercise exercise-like" id="exercise-38"><a data-knowl="" class="id-ref exercise-knowl original" data-refid="hk-exercise-38"><h6 class="heading">
<span class="type">Checkpoint</span><span class="space"> </span><span class="codenumber">3.8</span><span class="period">.</span>
</h6></a></article><div class="hidden-content tex2jax_ignore" id="hk-exercise-38"><article class="exercise exercise-like"><p id="p-163">Faça uma lista com um total de 7 alimentos e tente determinar as quantidedes ideais de cada alimento para atingir seus objetivos nutricionais. Qual o resulta obtido? O que você faria para obter uma resposta?</p>
<a data-knowl="" class="id-ref solution-knowl original" data-refid="hk-solution-6" id="solution-6"><span class="type">Solution.</span> </a><div class="hidden-content tex2jax_ignore" id="hk-solution-6"><div class="solution solution-like">O sistema, que originalmente admitia apenas uma solução, admite, agora, infinitas soluções. Como lidar com esse resultado? Uma possibilidade é fixar os valores das variáveis livres a seu critério. Outra opção (mais utilizada em problemas práticos) é otimizar determinadas variáveis, ou seja, maximizar ou minimizar seu valor. Vejamos a seguir:</div></div></article></div> como <article class="remark remark-like" id="minmax_lin_sys"><h6 class="heading">
<span class="type">Remark</span><span class="space"> </span><span class="codenumber">3.9</span><span class="period">.</span>
</h6>
<p id="p-164">Código para a resolução e otimização de sistemas lineares utilizando o método de Gauss-Jordan. A otimização foi realizada com apoio da biblioteca SciPy, do Python. O programa foi escrito para realizar otimizações com 5 equações e 7 variáveis. Caso deseje fazer com um número diferente, escreva/altere as funções objetivo e as funções limitadoras, conforme explicação e modelo no código.</p>
<div class="sagecell-sage" id="sage-27"><script type="text/x-sage">import numpy as np
import fractions
from scipy.optimize import minimize

# Aqui estão os rótulos do problema
und = "g"  # Unidade de massa
foods = ["Arroz", "Feijão", "Frango", "Alface", "Tomate"]  # Lista de alimentos (Em ordem)
quant = 100  # A cada quantos gramas/quilos/etc de comida temos a quantidade listada de nutrientes?
optimize = True
choiceMinMax = 1    # 1 para maximizar, 2 para minimizar
choiceFood = 2      # 0 para arroz, 1 para feijão, 2 para frango, 3 para alface, 4 para tomate
                    # Escolha choiceFood = 99 para minimizar/maximizar a qtd total

# Esta variável define o número de casas decimais para arredondamento dos resultados
decPlaces = 2

# Coloque aqui a matriz AMPLIADA do sistema:
ampl = []

# Estes códigos são referentes às funções que realizam a redução de Gauss-Jordan

def gaussianElimination(A,prin=True):
    a=0
    A = A + fractions.Fraction()

    if prin==True:
        print('A='+str(A))
    for j in range(np.shape(A)[1]-1):
        b=0
        for i in range(a,np.shape(A)[0]):
            if A[i,j] != 0:
                if a !=i:
                    A[[a,i]]=A[[i,a]]
                    if prin==True:
                        print('\n~'+str(A))
                if A[a,j]!=1:
                    A[a]=A[a]/A[a,j]
                    if prin==True:
                        print('\n~'+str(A))
                a=a+1
                b=1
                break
        if b==1:
            for i in range(a,np.shape(A)[0]):
                if A[i,j] != 0:
                    A[i]=A[i]-A[a-1]*A[i,j]
                if prin==True:
                    print('\n~'+str(A))

        i = 0
        for line in A:
            j = 0
            for elem in line:
                A[i][j] = float(elem)
                j += 1
            i += 1

        np.set_printoptions(formatter={'all':lambda x: str(fractions.Fraction(x).limit_denominator())})
    return A

def gaussJordan(A,prin=True):
    B=gaussianElimination(A,prin)
    #print('jordan')
    a=0
    for i in range(np.shape(A)[0]):
        b=0
        for j in range(np.shape(A)[1]):
            if B[np.shape(B)[0]-i-1,j] == 1 and b==0:
                b=j
                for k in range(np.shape(B)[0]-i-1):
                    B[np.shape(B)[0]-i-2-k]=B[np.shape(B)[0]-i-2-k]- B[np.shape(B)[0]-i-2-k,j]*B[B.shape[0]-i-1]
                    if prin==True:
                            print('\n~'+str(B))                
    np.set_printoptions(formatter={'all':lambda x: str(fractions.Fraction(x).limit_denominator())})
    return B

ampl = np.array(ampl)

# Dimensões da matriz de coeficientes A
m = np.shape(ampl)[0]
n = np.shape(ampl)[1] - 1

# Extraindo a matriz de coeficientes da matriz ampliada
A = ampl[0:m, 0:n]
A = np.array(A)

# Agora iremos verificar em qual caso o sistema se encaixa: Solução única, sem solução ou infinitas soluções
# Para isso, verificaremos o posto da matriz de coeficientes A e o posto da matriz ampliada
rankA = np.linalg.matrix_rank(A)
rankAmpl = np.linalg.matrix_rank(ampl)

# Para resolver o sistema linear, será feita a redução de Gauss-Jordan na matriz ampliada:
print("Escalonamento passo a passo da matriz ampliada do sistema:\n")
esc = gaussJordan(ampl)

# Devido ao truncamento em python, vamos filtrar valores infinitesimais para evitar que fiquem como "-0.0"
i = 0
changed = False
while i < m:
    if round(esc[i][n], decPlaces) == -0.0:
        esc[i][n] = 0
        changed = True
    i+=1

if changed == True:
    esc = gaussJordan(esc, prin=False)

# Imprimindo na tela a matriz ampliada escalonada reduzida
print("\nMatriz ampliada escalonada reduzida do sistema:")
print(esc, "\n")

# Aqui verificamos se o sistema é sem solução. De acordo com o teorema, se o posto da matriz ampliada
# for diferente do posto da matriz de coeficientes, o sistema não tem solução
if rankA != rankAmpl:
    raise Exception("O sistema não possui soluções reais!")

# Aqui verificamos se o sistema é de solução única
sol = []
if rankA == n:
    for i in range(rankA):
        sol.append((esc[i][n])*quant)

    # Aqui filtramos os valores: Valores negativos não fazem sentido nesse contexto
    for elem in sol:
        if elem < 0:
            raise Exception("O sistema linear possui solução negativa")

    # Aqui vamos imprimir os resultados de maneira formatada
    print("Você deverá consumir diariamente:")
    for i in range(n):
        print(f'{round(sol[i], decPlaces)} {und} de {foods[i]}')
    sair = 1

# Se a execução do programa chegar até aqui, temos várias soluções.
# Iremos trabalhar com otimização linear para interpretar os resultados.

if not sair:
    # inicialização de contadores
    i = 0
    j = 0

    # Array que contem as linhas com as variaveis fixas
    fixas = []
    # Array que contem as variáveis fixas
    varsFixas = []
    # Array com as linhas que contém variáveis livres
    livres = []

    while i < rankA:
        livres.append(i)
        i += 1

    # Aqui filtramos valores negativos:
    for line in esc:
        if line[n] < 0:
            raise Exception("O sistema linear possui solução negativa")


    # Aqui verificaremos as linhas da matriz escalonada reduzida em busca
    # de linhas que possuam apenas um número não nulo, em busca de variáveis
    # cujo valor seja fixado

    i = 0
    while i < rankA:
        notNullCount = 0
        j = 0
        while j < n:
            if esc[i][j] != 0:
                notNullCount += 1
                k = j
            j += 1
        if notNullCount == 1:
            livres.remove(i)
            varsFixas.append(k)
            fixas.append(i)
        i += 1


    # Já sabendo as relações entre variáveis fixas e livres, vamos imprimir
    # na tela os resultados (por ora, sem otimização)

    print("Você deverá consumir diariamente:")
    for i in fixas:
            print(f'{round(esc[i][n]*quant, decPlaces)} {und} de {foods[varsFixas[i]]}')

    for i in livres:
        varsLivres = []
        j = 0
        while j < n:
            if esc[i][j] != 0:
                varsLivres.append(j)
                k=j
            j += 1

        print("Você pode escolher consumir diariamente:")
        for j in range(len(varsLivres) - 1):
            print(f'{foods[varsLivres[j]]},', end=" ")
        print(f'{foods[k]},', end=" ")
        print(f'De modo que:')
        for j in range(len(varsLivres) - 1):
            print(f'{esc[i][varsLivres[j]]} porção de {foods[varsLivres[j]]} +', end=" ")
        print(f'{esc[i][k]} porção de {foods[k]} totalize {round(esc[i][n]*quant, decPlaces)}{und}')

    # Aqui será realizada a otimização dos resultados, ou seja,
    # No caso onde temos variáveis livres, podemos escolher qual
    # Desejamos otimizar o maximizar!
        
    if optimize:
        print("\nOtimização com scipy:")
        if choiceMinMax != 1 and choiceMinMax != 2:
            raise Exception("Escolha um valor de \"choiceMinMax\" válido!")

        if choiceFood in varsLivres:
            if choiceMinMax == 1:
                sign = -1
                def objective(x):
                    return -x[choiceFood]
            else:
                sign = 1
                def objective(x):
                    return x[choiceFood]

        elif choiceFood == 99:  
                if choiceMinMax == 1:
                    sign = -1
                    def objective(x):
                        return -sum(x)
                else:
                    sign = 1
                    def objective(x):
                        return sum(x)
                    
        else:
            raise Exception("Escolha um valor de \"choiceFood\" válido! O valor deve corresponder a uma das variáveis livres!")

        # Defina as funções de limitação da seguinte forma, substituindo N pelo número da linha da matriz escalonada do sistema;
        '''
        def constraintN(x):
            x1 = x[0]
            x2 = x[1]
            x3 = x[2]       DECLARE O NÚMERO DE VARIÁVEIS DO SEU SISTEMA!!
            x4 = x[3]
            ...
            xk = x[k-1]

            return esc[N][0] * x1 + esc[N][1] * x2 + esc[N][2] * x3 + esc[N][3] * x4 - esc[N][n]
        '''
        # Observe que deve existir uma função por linha nãu nula!

        def constraint1(x):
            x1 = x[0]
            x2 = x[1]
            x3 = x[2]
            x4 = x[3]
            x5 = x[4]
            x6 = x[5]
            x7 = x[6]
            return esc[0][0] * x1 + esc[0][1] * x2 + esc[0][2] * x3 + esc[0][3] * x4 + esc[0][4] * x5 + esc[0][5] * x6 + esc[0][6] * x7 - esc[0][n]

        def constraint2(x):
            x1 = x[0]
            x2 = x[1]
            x3 = x[2]
            x4 = x[3]
            x5 = x[4]
            x6 = x[5]
            x7 = x[6]
            return esc[1][0] * x1 + esc[1][1] * x2 + esc[1][2] * x3 + esc[1][3] * x4 + esc[1][4] * x5 + esc[1][5] * x6 + esc[1][6] * x7 - esc[1][n]

        def constraint3(x):
            x1 = x[0]
            x2 = x[1]
            x3 = x[2]
            x4 = x[3]
            x5 = x[4]
            x6 = x[5]
            x7 = x[6]
            return esc[2][0] * x1 + esc[2][1] * x2 + esc[2][2] * x3 + esc[2][3] * x4 + esc[2][4] * x5 + esc[2][5] * x6 + esc[2][6] * x7 - esc[2][n]

        def constraint4(x):
            x1 = x[0]
            x2 = x[1]
            x3 = x[2]
            x4 = x[3]
            x5 = x[4]
            x6 = x[5]
            x7 = x[6]
            return esc[3][0] * x1 + esc[3][1] * x2 + esc[3][2] * x3 + esc[3][3] * x4 + esc[3][4] * x5 + esc[3][5] * x6 + esc[3][6] * x7 - esc[3][n]

        def constraint5(x):
            x1 = x[0]
            x2 = x[1]
            x3 = x[2]
            x4 = x[3]
            x5 = x[4]
            x6 = x[5]
            x7 = x[6]
            return esc[3][0] * x1 + esc[3][1] * x2 + esc[3][2] * x3 + esc[3][3] * x4 + esc[3][4] * x5 + esc[4][5] * x6 + esc[4][6] * x7 - esc[4][n]

        # Declare todas as funções de limitações como constraints do numpy. Basta seguir o modelo:
        '''
        conN = {'type': 'eq', 'fun': constraintN}
        '''
        con1 = {'type': 'eq', 'fun': constraint1}
        con2 = {'type': 'eq', 'fun': constraint2}
        con3 = {'type': 'eq', 'fun': constraint3}
        con4 = {'type': 'eq', 'fun': constraint4}
        con5 = {'type': 'eq', 'fun': constraint5}

        # Adicione todas as constraints na lista a seguir:
        cons = [con1, con2, con3, con4, con5]

        # Aqui são declarados os limites de otimização (Essa parte evita numeros negativos, não mexa aqui)
        b = (0.0,0xFF)
        bnds = []
        for i in range(n):
            bnds.append(b)

        # Aqui estão os "chutes iniciais" para a otimização: (não mexa aqui)
        x0 = []
        for i in range(n):
            x0.append(0)

        sol = minimize(objective, x0, bounds=bnds, constraints=cons)

        print("\nOtimização concluida. Você deverá consumir:")
        for i in range(n):
            qtd = round(sol['x'][i]*quant, decPlaces)
            print(f'{qtd} {und} de {foods[i]}')
</script></div></article></section><section class="subsection" id="Proj2"><h3 class="heading hide-type">
<span class="type">Subsection</span> <span class="codenumber">3.2</span> <span class="title">Projeto 2 - Análise de circuitos resistivos</span>
</h3>
<p id="p-165">Em análise de circuitos, utilizamos a Lei de Ohm e as Leis de Kirchhoff de corrente e tensão. Ao encontrar as equações referentes ao circuito utilizando as leis básicas, precisamos montar um sistema linear para encontrar as correntes e quedas de tensão em cada ramo. Analise os circuitos dados utilizando essas três leis, encontre as equações do circuito e forneça-as ao programa em Python disponibilizado ao final da seção para resolver o sistema e encontras as correntes.</p>
<p id="p-166">Leis básicas:</p>
<ul class="disc">
<li id="li-107"><p id="p-derived-li-107"><em class="alert">Lei de Kirchhoff de Corrente:</em> Em qualquer nó, a soma das correntes entrando é igual à soma das correntes saindo.</p></li>
<li id="li-108"><p id="p-derived-li-108"><em class="alert">Lei de Kirchhoff de Tensão:</em> Ao longo de qualquer malha fechada, a soma dos ganhos e das quedas de tensão é igual a zero.</p></li>
<li id="li-109"><p id="p-derived-li-109"><em class="alert">Lei de Ohm:</em> A queda de tensão em um elemento resistivo é dada por \(E = Ri \)</p></li>
</ul>
<p id="p-167">Observe as aplicações das leis básicas nas soluções dos exemplos abaixo.</p>
<article class="example example-like" id="example-33"><a data-knowl="" class="id-ref example-knowl original" data-refid="hk-example-33"><h6 class="heading">
<span class="type">Example</span><span class="space"> </span><span class="codenumber">3.10</span><span class="period">.</span>
</h6></a></article><div class="hidden-content tex2jax_ignore" id="hk-example-33"><article class="example example-like"><p id="p-168">Obtenha as equações referentes à aplicação das leis básicas no seguinte cicuito:</p>
<figure class="figure figure-like" id="figure-3"><div class="image-box" style="width: 100%; margin-left: 0%; margin-right: 0%;"><img src="images/circuito1.png" class="contained" alt=""></div>
<figcaption><span class="type">Figure</span><span class="space"> </span><span class="codenumber">3.11<span class="period">.</span></span><span class="space"> </span>Circuito 1. Fonte: Leon, S. 2018</figcaption></figure><a data-knowl="" class="id-ref solution-knowl original" data-refid="hk-solution-7" id="solution-7"><span class="type">Solution.</span> </a><div class="hidden-content tex2jax_ignore" id="hk-solution-7"><div class="solution solution-like">
<p id="p-169"><em class="alert">Aplicação da LKC:</em></p>
<p id="p-170">Observamos que, no nó A, entram as correntes \(i_1\) e \(i_3\text{,}\) e sai a corrente \(i_2\text{.}\) Por outro lado, no nó B, entra a corrente \(i_2\) e saem as correntes \(i_1\) e \(i_3\text{.}\) Assim, obtemos as equações:</p>
<div class="displaymath">
\begin{gather*}
i_1 - i_2 + i_3 = 0 \\
-i_1 + i_2 - i_3 = 0 
\end{gather*}
</div>
<p id="p-171"><em class="alert">Aplicação da Lei de Ohm:</em></p>
<p id="p-172">Aplicando a lei de Ohm, descobrimos que a queda de tensão em cada resistor é:</p>
<ul class="disc">
<li id="li-110"><p id="p-derived-li-110">Resistor de 4 ohms: \(E = 4i_1\)</p></li>
<li id="li-111"><p id="p-derived-li-111">Resistor de 3 ohms: \(E = 3i_3\)</p></li>
<li id="li-112"><p id="p-derived-li-112">Resistor de 2 ohms (à esquerda do nó B): \(E = 2i_2\)</p></li>
<li id="li-113"><p id="p-derived-li-113">Resistor de 2 ohms (abaixo do nó B): \(E = 2i_3\)</p></li>
</ul>
<p id="p-173"><em class="alert">Aplicação da LKT:</em></p>
<p id="p-174">Aplicando a LKT, obtemos uma equação para cada malha do circuito. Vejamos:</p>
<div class="displaymath">
\begin{gather*}
4i_1 + 2i_2 = 8 \\
2i_2 + 2i_3 + 3i_3 = 9 
\end{gather*}
</div>
<p id="p-175"><em class="alert">Ao final temos:</em></p>
<div class="displaymath">
\begin{gather*}
i_1 - i_2 + i_3 = 0 \\
4i_1 + 2i_2 = 8 \\
2i_2 + 5i_3 = 9 
\end{gather*}
</div>
<p id="p-176">Agora basta colocar as equações na forma matricial e fornecer ao programa.</p>
</div></div></article></div>
<article class="example example-like" id="example-34"><a data-knowl="" class="id-ref example-knowl original" data-refid="hk-example-34"><h6 class="heading">
<span class="type">Example</span><span class="space"> </span><span class="codenumber">3.12</span><span class="period">.</span>
</h6></a></article><div class="hidden-content tex2jax_ignore" id="hk-example-34"><article class="example example-like"><p id="p-177">Obtenha as equações referentes à aplicação das leis básicas no seguinte cicuito:</p>
<figure class="figure figure-like" id="figure-4"><div class="image-box" style="width: 100%; margin-left: 0%; margin-right: 0%;"><img src="images/circuito2.png" class="contained" alt=""></div>
<figcaption><span class="type">Figure</span><span class="space"> </span><span class="codenumber">3.13<span class="period">.</span></span><span class="space"> </span>Circuito 2. Fonte: Leon, S. 2018</figcaption></figure><a data-knowl="" class="id-ref solution-knowl original" data-refid="hk-solution-8" id="solution-8"><span class="type">Solution.</span> </a><div class="hidden-content tex2jax_ignore" id="hk-solution-8"><div class="solution solution-like">
<p id="p-178"><em class="alert">Aplicação da LKC:</em></p>
<p id="p-179">Observamos que, no nó A, entram as correntes \(i_1\) e \(i_3\text{,}\) e sai a corrente \(i_2\text{.}\) Por outro lado, no nó B, entra a corrente \(i_2\) e saem as correntes \(i_1\) e \(i_3\text{.}\) Assim, obtemos as equações:</p>
<div class="displaymath">
\begin{gather*}
i_1 - i_2 + i_3 = 0 \\
-i_1 + i_2 - i_3 = 0 
\end{gather*}
</div>
<p id="p-180"><em class="alert">Aplicação da Lei de Ohm:</em></p>
<p id="p-181">Aplicando a lei de Ohm, descobrimos que a queda de tensão em cada resistor é:</p>
<ul class="disc">
<li id="li-114"><p id="p-derived-li-114">Resistor de 3 ohms: \(E = 3i_3\)</p></li>
<li id="li-115"><p id="p-derived-li-115">Resistor de 2 ohms (acima do nó B): \(E = 2i_1\)</p></li>
<li id="li-116"><p id="p-derived-li-116">Resistor de 2 ohms (à esquerda do nó B): \(E = 2i_2\)</p></li>
</ul>
<p id="p-182"><em class="alert">Aplicação da LKT:</em></p>
<p id="p-183">Aplicando a LKT, obtemos uma equação para cada malha do circuito. Vejamos:</p>
<div class="displaymath">
\begin{gather*}
2i_1 + 2i_2 = 16 \\
2i_2 + 3i_3 = 0 
\end{gather*}
</div>
<p id="p-184"><em class="alert">Ao final temos:</em></p>
<div class="displaymath">
\begin{gather*}
i_1 - i_2 + i_3 = 0 \\
2i_1 + 2i_2 = 16 \\
2i_2 + 3i_3 = 0 
\end{gather*}
</div>
<p id="p-185">Agora basta colocar as equações na forma matricial e fornecer ao programa.</p>
</div></div></article></div>
<article class="example example-like" id="example-35"><a data-knowl="" class="id-ref example-knowl original" data-refid="hk-example-35"><h6 class="heading">
<span class="type">Example</span><span class="space"> </span><span class="codenumber">3.14</span><span class="period">.</span>
</h6></a></article><div class="hidden-content tex2jax_ignore" id="hk-example-35"><article class="example example-like"><p id="p-186">Obtenha as equações referentes à aplicação das leis básicas no seguinte cicuito:</p>
<figure class="figure figure-like" id="figure-5"><div class="image-box" style="width: 100%; margin-left: 0%; margin-right: 0%;"><img src="images/circuito3.png" class="contained" alt=""></div>
<figcaption><span class="type">Figure</span><span class="space"> </span><span class="codenumber">3.15<span class="period">.</span></span><span class="space"> </span>Circuito 3. Fonte: Leon, S. 2018</figcaption></figure><a data-knowl="" class="id-ref solution-knowl original" data-refid="hk-solution-9" id="solution-9"><span class="type">Solution.</span> </a><div class="hidden-content tex2jax_ignore" id="hk-solution-9"><div class="solution solution-like">
<p id="p-187"><em class="alert">Aplicação da LKC:</em></p>
<p id="p-188">Observamos que, no nó A, saem as correntes \(i_1\) e \(i_3\text{,}\) e entra a corrente \(i_2\text{.}\) Por outro lado, no nó B, sai a corrente \(i_2\) e entram as correntes \(i_1\) e \(i_3\text{.}\) Assim, obtemos as equações:</p>
<div class="displaymath">
\begin{gather*}
-i_1 + i_2 - i_3 = 0 \\
i_1 - i_2 + i_3 = 0 
\end{gather*}
</div>
<p id="p-189"><em class="alert">Aplicação da Lei de Ohm:</em></p>
<p id="p-190">Aplicando a lei de Ohm, descobrimos que a queda de tensão em cada resistor é:</p>
<ul class="disc">
<li id="li-117"><p id="p-derived-li-117">Resistor de 4 ohms: \(E = 4i_2\)</p></li>
<li id="li-118"><p id="p-derived-li-118">Resistor de 2 ohms (superior): \(E = 2i_1\)</p></li>
<li id="li-119"><p id="p-derived-li-119">Resistor de 2 ohms (inferior): \(E = 2i_3\)</p></li>
</ul>
<p id="p-191"><em class="alert">Aplicação da LKT:</em></p>
<p id="p-192">Aplicando a LKT, obtemos uma equação para cada malha do circuito. Vejamos:</p>
<div class="displaymath">
\begin{gather*}
2i_1 + 4i_2 = 20 \\
4i_2 + 2i_3 = 20 
\end{gather*}
</div>
<p id="p-193"><em class="alert">Ao final temos:</em></p>
<div class="displaymath">
\begin{gather*}
i_1 - i_2 + i_3 = 0 \\
2i_1 + 4i_2 = 20 \\
4i_2 + 2i_3 = 20 
\end{gather*}
</div>
<p id="p-194">Agora basta colocar as equações na forma matricial e fornecer ao programa.</p>
</div></div></article></div>
<article class="exercise exercise-like" id="exercise-39"><a data-knowl="" class="id-ref exercise-knowl original" data-refid="hk-exercise-39"><h6 class="heading">
<span class="type">Checkpoint</span><span class="space"> </span><span class="codenumber">3.16</span><span class="period">.</span>
</h6></a></article><div class="hidden-content tex2jax_ignore" id="hk-exercise-39"><article class="exercise exercise-like"><p id="p-195"><dfn class="terminology">Altere os valores das resistências no circuito abaixo e utilize o seu circuito</dfn> para obter o sistema de equações referentes à aplicação das leis básicas para as correntes em cada fio (entre nodos):</p>
<figure class="figure figure-like" id="figure-6"><div class="image-box" style="width: 100%; margin-left: 0%; margin-right: 0%;"><img src="images/Linalg_circuit_2.png" class="contained" alt=""></div>
<figcaption><span class="type">Figure</span><span class="space"> </span><span class="codenumber">3.17<span class="period">.</span></span><span class="space"> </span>Circuito. Fonte: Wikibooks - Linear Algebra/Topic: Analyzing Networks</figcaption></figure></article></div>
<article class="exercise exercise-like" id="exercise-40"><a data-knowl="" class="id-ref exercise-knowl original" data-refid="hk-exercise-40"><h6 class="heading">
<span class="type">Checkpoint</span><span class="space"> </span><span class="codenumber">3.18</span><span class="period">.</span>
</h6></a></article><div class="hidden-content tex2jax_ignore" id="hk-exercise-40"><article class="exercise exercise-like"><p id="p-196">Utilize os códigos em python para resolver o sistema que você criou. Explique como e porque está usando os códigos.</p></article></div>
<article class="remark remark-like" id="remark-14"><h6 class="heading">
<span class="type">Remark</span><span class="space"> </span><span class="codenumber">3.19</span><span class="period">.</span>
</h6>Utilize o código a seguir em Python para avaliar os sistemas lineares obtidos em cada um dos circuitos. <div class="sagecell-sage" id="sage-28"><script type="text/x-sage">import numpy as np
import fractions

# Aqui estão os rótulos do problema
und = "A"  # Unidade de corrente
vars = ["i1", "i2", "i3"]
# Esta variável define o número de casas decimais para arredondamento dos resultados
decPlaces = 2

# Coloque aqui a matriz AMPLIADA do sistema:
ampl = [[0, 0, 0, 0],
        [0, 0, 0, 0],
        [0, 0, 0, 0]]

# Estes códigos são referentes às funções que realizam a redução de Gauss-Jordan

def gaussianElimination(A,prin=True):
    a=0
    A = A + fractions.Fraction()

    if prin==True:
        print('A='+str(A))
    for j in range(np.shape(A)[1]-1):
        b=0
        for i in range(a,np.shape(A)[0]):
            if A[i,j] != 0:
                if a !=i:
                    A[[a,i]]=A[[i,a]]
                    if prin==True:
                        print('\n~'+str(A))
                if A[a,j]!=1:
                    A[a]=A[a]/A[a,j]
                    if prin==True:
                        print('\n~'+str(A))
                a=a+1
                b=1
                break
        if b==1:
            for i in range(a,np.shape(A)[0]):
                if A[i,j] != 0:
                    A[i]=A[i]-A[a-1]*A[i,j]
                if prin==True:
                    print('\n~'+str(A))

        i = 0
        for line in A:
            j = 0
            for elem in line:
                A[i][j] = float(elem)
                j += 1
            i += 1

    np.set_printoptions(formatter={'all':lambda x: str(fractions.Fraction(x).limit_denominator())})
    return A

def gaussJordan(A,prin=True):
    B=gaussianElimination(A,prin)
    #print('jordan')
    a=0
    for i in range(np.shape(A)[0]):
        b=0
        for j in range(np.shape(A)[1]):
            if B[np.shape(B)[0]-i-1,j] == 1 and b==0:
                b=j
                for k in range(np.shape(B)[0]-i-1):
                    B[np.shape(B)[0]-i-2-k]=B[np.shape(B)[0]-i-2-k]- B[np.shape(B)[0]-i-2-k,j]*B[B.shape[0]-i-1]
                    if prin==True:
                            print('\n~'+str(B))                
    np.set_printoptions(formatter={'all':lambda x: str(fractions.Fraction(x).limit_denominator())})
    return B

ampl = np.array(ampl)
done = False

# Dimensões da matriz de coeficientes A
m = np.shape(ampl)[0]
n = np.shape(ampl)[1] - 1

# Extraindo a matriz de coeficientes da matriz ampliada
A = ampl[0:m, 0:n]
A = np.array(A)

# Agora iremos verificar em qual caso o sistema se encaixa: Solução única, sem solução ou infinitas soluções
# Para isso, verificaremos o posto da matriz de coeficientes A e o posto da matriz ampliada
rankA = np.linalg.matrix_rank(A)
rankAmpl = np.linalg.matrix_rank(ampl)

# Para resolver o sistema linear, será feita a redução de Gauss-Jordan na matriz ampliada:
print("Escalonamento passo a passo da matriz ampliada do sistema:\n")
esc = gaussJordan(ampl)

# Devido ao truncamento em python, vamos filtrar valores infinitesimais para evitar que fiquem como "-0.0"
i = 0
changed = False
while i < m:
    if round(esc[i][n], decPlaces) == -0.0:
        esc[i][n] = 0
        changed = True
    i+=1

if changed == True:
    esc = gaussJordan(esc, prin=False)

# Imprimindo na tela a matriz ampliada escalonada reduzida
print("\nMatriz ampliada escalonada reduzida do sistema:")
print(esc, "\n")

# Aqui verificamos se o sistema é sem solução. De acordo com o teorema, se o posto da matriz ampliada
# for diferente do posto da matriz de coeficientes, o sistema não tem solução
if rankA != rankAmpl:
    raise Exception("O sistema não possui soluções reais!")

# Aqui verificamos se o sistema é de solução única
sol = []
if rankA == n:
    for i in range(rankA):
        sol.append((esc[i][n]))

    # Aqui vamos imprimir os resultados de maneira formatada
    print("As correntes encontradas são:")
    for i in range(n):
        print(f'{vars[i]} = {round(sol[i], decPlaces)} {und}')
    done = True
# Se a execução do programa chegar até aqui, temos várias soluções.
# Nesse contexto, várias soluções não fazem sentido.
if not done:
    raise Exception("O sistema não possui solução única!")
</script></div></article></section><section class="subsection" id="Proj3"><h3 class="heading hide-type">
<span class="type">Subsection</span> <span class="codenumber">3.3</span> <span class="title">Projeto 3 - Ajustando dados aleatórios</span>
</h3>
<p id="p-197">Neste projeto, será explorado o método dos quadrados mínimos, método de otimização que tem por objetivo encontrar funções que melhor descrevem um conjunto de pontos em \(\mathbb{R}^n \text{.}\)</p>
<p id="p-198">Nesta atividade, você deve utilizar um código em python para gerar 10 pontos aleatórios no plano, e depois encontrar as funções linear, quadrática, cúbica e exponencial que melhor se ajustam a esses pontos utilizando o método dos quadrados mínimos. Você pode observar a função que encontrou graficamente e conferir seus resultados utilizando os códigos disponibilizados em cada checkpoint.</p>
<article class="remark remark-like" id="remark-15"><h6 class="heading">
<span class="type">Remark</span><span class="space"> </span><span class="codenumber">3.20</span><span class="period">.</span>
</h6>Execute este código para gerar seus pontos aleatórios. Você pode modificar os valores mínimo e máximo de x e y. Não altere os valores de N_PONTOS e DISTORCAO <div class="sagecell-sage" id="sage-29"><script type="text/x-sage">import random as rd
import matplotlib.pyplot as plt

MIN_X = 0
MAX_X = 50
MIN_Y = 0
MAX_Y = 50
N_PONTOS = 10
DISTORCAO = 7

def randomPoint(minX, maxX, minY, maxY):
    x = rd.randrange(minX, maxX) + rd.random()
    y = rd.randrange(minY, maxY) + rd.random()
    x = round(x, 2)
    y = round(y, 2)
    return (x,y)

def generatePoints(totalPoints, minX, maxX, minY, maxY):
    points = []
    cresc = rd.randrange(0,2)
    step = (maxY-minY)/totalPoints

    if cresc == 1:
        y0 = minY
        for i in range(totalPoints):
            infLimitX = round(minX + ((maxX-minX)/totalPoints) * i)
            supLimitX = round(minX + ((maxX-minX)/totalPoints) * (i+1))
            infLimitY = round(y0 + i*step) - DISTORCAO if round(y0 + i*step) - DISTORCAO > minY else round(y0 + i*step)
            supLimitY = round(y0 + (i+1)*step) + DISTORCAO if round(y0 + (i+1)*step) < maxY else round(y0 + (i+1)*step)
            point = randomPoint(infLimitX, supLimitX, infLimitY, supLimitY)
            points.append(point)

    else:
        y0 = maxY
        for i in range(totalPoints):
            infLimitX = round(minX + ((maxX-minX)/totalPoints) * i)
            supLimitX = round(minX + ((maxX-minX)/totalPoints) * (i+1))
            infLimitY = round(y0 - (i+1)*step) - DISTORCAO if round(y0 - (i+1)*step) - DISTORCAO > minY else round(y0 - (i+1)*step)
            supLimitY = round(y0 - i*step) + DISTORCAO if round(y0 - i*step) < maxY else round(y0 - i*step)
            point = randomPoint(infLimitX, supLimitX, infLimitY, supLimitY)
            points.append(point)

    return points

def printPoints(points):
    print("Os pontos gerados são:")
    for point in points:
        print(point)
    print("\n Para copiar e colar nos codigos seguintes:")
    print("points = ", end='')
    print(points)

def plotPoints(points, xMin, xMax, yMin, yMax):
    plt.clf()
    x = []
    y = []
    for point in points:
        x.append(point[0])
        y.append(point[1])
    
    plt.xlim(xMin-xMin/10, xMax+xMax/10)
    plt.ylim(yMin-yMin/10, yMax+yMax/10)
    plt.scatter(x, y, c='#000000')


points = generatePoints(N_PONTOS, MIN_X, MAX_X, MIN_Y, MAX_Y)
plt.clf()
printPoints(points)
plotPoints(points, MIN_X, MAX_X, MIN_Y, MAX_Y)
plt.show()
</script></div></article><article class="exercise exercise-like" id="exercise-41"><a data-knowl="" class="id-ref exercise-knowl original" data-refid="hk-exercise-41"><h6 class="heading">
<span class="type">Checkpoint</span><span class="space"> </span><span class="codenumber">3.21</span><span class="period">.</span>
</h6></a></article><div class="hidden-content tex2jax_ignore" id="hk-exercise-41"><article class="exercise exercise-like"><p id="p-199">Utilizando o método dos quadrados mínimos, ajuste uma função LINEAR aos pontos obtidos. Você pode inserir seus pontos e a função que encontrou no código abaixo para observá-los graficamente e calcular o erro associado à linearização.</p>
<div class="hidden-sagecell-sage" id="sage-30"><script type="text/x-sage">import numpy as np
import matplotlib.pyplot as plt

# Para observar sua solução graficamente, insira os coeficientes de sua função linear:
# f(x) = ax + b
a =
b =

points =

def calcBoundaries(points):
    xMax = points[0][0]
    xMin =  points[0][0]
    yMax = points[0][1]
    yMin =  points[0][1]
    for point in points:
        if point[0] > xMax:
            xMax = point[0]
        if point[0] < xMin:
            xMin = point[0]
        if point[1] > yMax:
            yMax = point[1]
        if point[1] < yMin:
            yMin = point[1]

    plt.xlim(xMin-5, xMax+5) 
    plt.ylim(yMin-5, yMax+5)
    return (xMin-5, xMax+5)

def plotPoints(points):
    x = []
    y = []
    for point in points:
        x.append(point[0])
        y.append(point[1])
    
    plt.scatter(x, y, c='#000000')

def PolyCoefficients(x, coeffs):
    o = len(coeffs)
    y = 0
    for i in range(o):
        y += coeffs[i]*x**i
    return y

def plotLine(x, coeffs):
    polynomial = PolyCoefficients(x, coeffs)
    plt.plot(x, polynomial)

def calcError(points, coeffs):
    error = 0

    for point in points:
        error += ((point[1] - (coeffs[0] + coeffs[1]*point[0]))**2)

    return np.round(error, 3)

boundaries = calcBoundaries(points)
x = np.arange(boundaries[0], boundaries[1], 0.001)
coeffs = [b, a]
plt.clf()
plotPoints(points)
plotLine(x, coeffs)
print(f'O erro associado é {calcError(points, coeffs)}')
plt.show()
</script></div>
<a data-knowl="" class="id-ref solution-knowl original" data-refid="hk-solution-10" id="solution-10"><span class="type">Solution.</span> </a><div class="hidden-content tex2jax_ignore" id="hk-solution-10"><div class="solution solution-like">
<p id="p-200">Utilize o código abaixo para conferir sua resposta. Observe o passo a passo da resolução.</p>
<div class="hidden-sagecell-sage" id="sage-31"><script type="text/x-sage">import numpy as np
import matplotlib.pyplot as plt

points =

def calcBoundaries(points):
    xMax = points[0][0]
    xMin =  points[0][0]
    yMax = points[0][1]
    yMin =  points[0][1]
    for point in points:
        if point[0] > xMax:
            xMax = point[0]
        if point[0] < xMin:
            xMin = point[0]
        if point[1] > yMax:
            yMax = point[1]
        if point[1] < yMin:
            yMin = point[1]

    plt.xlim(xMin-5, xMax+5) 
    plt.ylim(yMin-5, yMax+5)
    return (xMin-5, xMax+5)

def plotPoints(points):
    x = []
    y = []
    for point in points:
        x.append(point[0])
        y.append(point[1])
    
    plt.scatter(x, y, c='#000000')

def PolyCoefficients(x, coeffs):
    o = len(coeffs)
    y = 0
    for i in range(o):
        y += coeffs[i]*x**i
    return y

def plotLine(x, coeffs):
    polynomial = PolyCoefficients(x, coeffs)
    plt.plot(x, polynomial)

def calcError(points, coeffs):
    error = 0

    for point in points:
        error += ((point[1] - (coeffs[0][0] + coeffs[1][0]*point[0]))**2)

    return np.round(error, 3)

def normalEq(A, B):
    np.set_printoptions(formatter={'all':lambda x: str(np.round(x,2))})
    print("Escrevendo o sistema sobredeterminado na forma Ax = b, obtemos: ")
    print("A: ", end='')
    print(A)
    print("\nB: ", end='')
    print(B)

    At = np.transpose(A)
    AtAinv = np.dot(At, A)
    AtAinv = np.linalg.inv(AtAinv)
    sol = np.dot(np.dot(AtAinv, At), B)
    
    print("\nA matriz transposta de A é:")
    print(At)
    print("\nA matriz inversa do produto entre A^t e A é:")
    print(AtAinv)
    print("\nResolvendo a equação normal (A^t A)^(-1) * A^t * b, encontra-se a solução de mínimos quadrados x:")
    print(sol)
    return sol

def linearFit(points):
    A = []
    B = []

    for point in points:
        A.append([1, point[0]])
        B.append([point[1]])

    A = np.array(A)
    B = np.array(B)
    sol = normalEq(A, B)

    print(f'\nA função linear que melhor se adapta aos pontos é: {np.round(sol[0][0],3)} + ({np.round(sol[1][0], 3)})x')
    error = calcError(points, sol)
    print(f'O erro associado é igual a {error}')
    print("\nObservando a solução graficamente:")
    return sol

boundaries = calcBoundaries(points)
x = np.arange(boundaries[0], boundaries[1], 0.001)
coeffs = linearFit(points)
plt.clf()
plotPoints(points)
plotLine(x, coeffs)
plt.show()
</script></div>
</div></div></article></div>
<article class="exercise exercise-like" id="exercise-42"><a data-knowl="" class="id-ref exercise-knowl original" data-refid="hk-exercise-42"><h6 class="heading">
<span class="type">Checkpoint</span><span class="space"> </span><span class="codenumber">3.22</span><span class="period">.</span>
</h6></a></article><div class="hidden-content tex2jax_ignore" id="hk-exercise-42"><article class="exercise exercise-like"><p id="p-201">Utilizando o método dos quadrados mínimos, ajuste uma função QUADRÁTICA aos pontos obtidos. Você pode inserir seus pontos e a função que encontrou no código abaixo para observá-los graficamente e calcular o erro associado ao ajuste.</p>
<div class="hidden-sagecell-sage" id="sage-32"><script type="text/x-sage">import numpy as np
import matplotlib.pyplot as plt

# Para observar sua solução graficamente, insira os coeficientes de sua função quadrática:
# f(x) = ax^2 + bx + c
a =
b =
c = 

points = 

def calcBoundaries(points):
    xMax = points[0][0]
    xMin =  points[0][0]
    yMax = points[0][1]
    yMin =  points[0][1]
    for point in points:
        if point[0] > xMax:
            xMax = point[0]
        if point[0] < xMin:
            xMin = point[0]
        if point[1] > yMax:
            yMax = point[1]
        if point[1] < yMin:
            yMin = point[1]

    plt.xlim(xMin-5, xMax+5) 
    plt.ylim(yMin-5, yMax+5)
    return (xMin-5, xMax+5)

def plotPoints(points):
    x = []
    y = []
    for point in points:
        x.append(point[0])
        y.append(point[1])
    
    plt.scatter(x, y, c='#000000')

def PolyCoefficients(x, coeffs):
    o = len(coeffs)
    y = 0
    for i in range(o):
        y += coeffs[i]*x**i
    return y

def plotLine(x, coeffs):
    polynomial = PolyCoefficients(x, coeffs)
    plt.plot(x, polynomial)

def calcError(points, coeffs):
    error = 0

    for point in points:
        error += ((point[1] - (coeffs[0] + coeffs[1]*point[0] + coeffs[2]*(point[0])**2))**2)

    return np.round(error, 3)

boundaries = calcBoundaries(points)
x = np.arange(boundaries[0], boundaries[1], 0.001)
coeffs = [c, b, a]
plt.clf()
plotPoints(points)
plotLine(x, coeffs)
print(f'O erro associado é {calcError(points, coeffs)}')
plt.show()
</script></div>
<a data-knowl="" class="id-ref solution-knowl original" data-refid="hk-solution-11" id="solution-11"><span class="type">Solution.</span> </a><div class="hidden-content tex2jax_ignore" id="hk-solution-11"><div class="solution solution-like">
<p id="p-202">Utilize o código abaixo para conferir sua resposta. Observe o passo a passo da resolução.</p>
<div class="hidden-sagecell-sage" id="sage-33"><script type="text/x-sage">import numpy as np
import matplotlib.pyplot as plt

points =

def calcBoundaries(points):
    xMax = points[0][0]
    xMin =  points[0][0]
    yMax = points[0][1]
    yMin =  points[0][1]
    for point in points:
        if point[0] > xMax:
            xMax = point[0]
        if point[0] < xMin:
            xMin = point[0]
        if point[1] > yMax:
            yMax = point[1]
        if point[1] < yMin:
            yMin = point[1]

    plt.xlim(xMin-5, xMax+5)
    plt.ylim(yMin-5, yMax+5)
    return (xMin-5, xMax+5)

def plotPoints(points):
    x = []
    y = []
    for point in points:
        x.append(point[0])
        y.append(point[1])
    
    plt.scatter(x, y, c='#000000')

def PolyCoefficients(x, coeffs):
    o = len(coeffs)
    y = 0
    for i in range(o):
        y += coeffs[i]*x**i
    return y

def plotLine(x, coeffs):
    polynomial = PolyCoefficients(x, coeffs)
    plt.plot(x, polynomial)

def calcError(points, coeffs):
    error = 0

    for point in points:
        error += ((point[1] - (coeffs[0][0] + coeffs[1][0]*point[0] + coeffs[2][0]*(point[0])**2))**2)

    return np.round(error, 3)

def normalEq(A, B):
    np.set_printoptions(formatter={'all':lambda x: str(np.round(x,2))})
    print("Escrevendo o sistema sobredeterminado na forma Ax = b, obtemos: ")
    print("A: ", end='')
    print(A)
    print("\nB: ", end='')
    print(B)

    At = np.transpose(A)
    AtAinv = np.dot(At, A)
    AtAinv = np.linalg.inv(AtAinv)
    sol = np.dot(np.dot(AtAinv, At), B)

    print("\nA matriz transposta de A é:")
    print(At)
    print("\nA matriz inversa do produto entre A^t e A é:")
    print(AtAinv)
    print("\nResolvendo a equação normal (A^t A)^(-1) * A^t * b, encontra-se a solução de mínimos quadrados x:")
    print(sol)
    return sol

def quadraticFit(points):
    A = []
    B = []

    for point in points:
        A.append([1, point[0], point[0]**2])
        B.append([point[1]])

    A = np.array(A)
    B = np.array(B)
    sol = normalEq(A, B)

    print(f'\nA função quadratica que melhor se adapta aos pontos é: {np.round(sol[0][0],3)} + ({np.round(sol[1][0], 3)})x + ({np.round(sol[2][0], 3)})x^2')
    error = calcError(points, sol)
    print(f'O erro associado é igual a {error}')
    print("\nObservando a solução graficamente:")
    return sol

boundaries = calcBoundaries(points)
x = np.arange(boundaries[0], boundaries[1], 0.001)
coeffs = quadraticFit(points)
plt.clf()
plotPoints(points)
plotLine(x, coeffs)
plt.show()
</script></div>
</div></div></article></div>
<article class="exercise exercise-like" id="exercise-43"><a data-knowl="" class="id-ref exercise-knowl original" data-refid="hk-exercise-43"><h6 class="heading">
<span class="type">Checkpoint</span><span class="space"> </span><span class="codenumber">3.23</span><span class="period">.</span>
</h6></a></article><div class="hidden-content tex2jax_ignore" id="hk-exercise-43"><article class="exercise exercise-like"><p id="p-203">Utilizando o método dos quadrados mínimos, ajuste uma função CÚBICA aos pontos obtidos. Você pode inserir seus pontos e a função que encontrou no código abaixo para observá-los graficamente e calcular o erro associado ao ajuste.</p>
<div class="hidden-sagecell-sage" id="sage-34"><script type="text/x-sage">import numpy as np
import matplotlib.pyplot as plt

# Para observar sua solução graficamente, insira os coeficientes de sua função cúbica:
# f(x) = ax^3 + bx^2 + cx + d
a = 
b =
c = 
d = 

points = 

def calcBoundaries(points):
    xMax = points[0][0]
    xMin =  points[0][0]
    yMax = points[0][1]
    yMin =  points[0][1]
    for point in points:
        if point[0] > xMax:
            xMax = point[0]
        if point[0] < xMin:
            xMin = point[0]
        if point[1] > yMax:
            yMax = point[1]
        if point[1] < yMin:
            yMin = point[1]

    plt.xlim(xMin-5, xMax+5) 
    plt.ylim(yMin-5, yMax+5)
    return (xMin-5, xMax+5)

def plotPoints(points):
    x = []
    y = []
    for point in points:
        x.append(point[0])
        y.append(point[1])
    
    plt.scatter(x, y, c='#000000')

def PolyCoefficients(x, coeffs):
    o = len(coeffs)
    y = 0
    for i in range(o):
        y += coeffs[i]*x**i
    return y

def plotLine(x, coeffs):
    polynomial = PolyCoefficients(x, coeffs)
    plt.plot(x, polynomial)

def calcError(points, coeffs): 
    error = 0

    for point in points:
        error += ((point[1] - (coeffs[0] + coeffs[1]*point[0] + coeffs[2]*(point[0])**2 + coeffs[3]*(point[0])**3))**2)

    return np.round(error, 3)

boundaries = calcBoundaries(points)
x = np.arange(boundaries[0], boundaries[1], 0.001)
coeffs = [d, c, b, a]
plt.clf()
plotPoints(points)
plotLine(x, coeffs)
print(f'O erro associado é {calcError(points, coeffs)}')
plt.show()
</script></div>
<a data-knowl="" class="id-ref solution-knowl original" data-refid="hk-solution-12" id="solution-12"><span class="type">Solution.</span> </a><div class="hidden-content tex2jax_ignore" id="hk-solution-12"><div class="solution solution-like">
<p id="p-204">Utilize o código abaixo para conferir sua resposta. Observe o passo a passo da resolução.</p>
<div class="hidden-sagecell-sage" id="sage-35"><script type="text/x-sage">import numpy as np
import matplotlib.pyplot as plt

points = 

def calcBoundaries(points):
    xMax = points[0][0]
    xMin =  points[0][0]
    yMax = points[0][1]
    yMin =  points[0][1]
    for point in points:
        if point[0] > xMax:
            xMax = point[0]
        if point[0] < xMin:
            xMin = point[0]
        if point[1] > yMax:
            yMax = point[1]
        if point[1] < yMin:
            yMin = point[1]

    plt.xlim(xMin-5, xMax+5)
    plt.ylim(yMin-5, yMax+5)
    return (xMin-5, xMax+5)

def plotPoints(points):
    x = []
    y = []
    for point in points:
        x.append(point[0])
        y.append(point[1])
    
    plt.scatter(x, y, c='#000000')

def PolyCoefficients(x, coeffs):
    o = len(coeffs)
    y = 0
    for i in range(o):
        y += coeffs[i]*x**i
    return y

def plotLine(x, coeffs):
    polynomial = PolyCoefficients(x, coeffs)
    plt.plot(x, polynomial)

def calcError(points, coeffs):
    error = 0

    for point in points:
        error += ((point[1] - (coeffs[0][0] + coeffs[1][0]*point[0] + coeffs[2][0]*(point[0])**2 + coeffs[3][0]*(point[0])**3))**2)

    return np.round(error, 3)

def normalEq(A, B):
    np.set_printoptions(formatter={'all':lambda x: str(np.round(x,2))})
    print("Escrevendo o sistema sobredeterminado na forma Ax = b, obtemos: ")
    print("A: ", end='')
    print(A)
    print("\nB: ", end='')
    print(B)

    At = np.transpose(A)
    AtAinv = np.dot(At, A)
    AtAinv = np.linalg.inv(AtAinv)
    sol = np.dot(np.dot(AtAinv, At), B)
    
    print("\nA matriz transposta de A é:")
    print(At)
    print("\nA matriz inversa do produto entre A^t e A é:")
    print(AtAinv)
    print("\nResolvendo a equação normal (A^t A)^(-1) * A^t * b, encontra-se a solução de mínimos quadrados x:")
    print(sol)
    return sol

def cubicFit(points):
    A = []
    B = []

    for point in points:
        A.append([1, point[0], point[0]**2, point[0]**3])
        B.append([point[1]])

    A = np.array(A)
    B = np.array(B)
    sol = normalEq(A, B)

    print(f'\nA função cubica que melhor se adapta aos pontos é: {np.round(sol[0][0],3)} + ({np.round(sol[1][0], 3)})x + ({np.round(sol[2][0], 3)})x^2 + ({np.round(sol[3][0], 3)})x^3')
    error = calcError(points, sol)
    print(f'O erro associado é igual a {error}')
    print("\nObservando a solução graficamente:")
    return sol

boundaries = calcBoundaries(points)
x = np.arange(boundaries[0], boundaries[1], 0.001)
coeffs = cubicFit(points)
plt.clf()
plotPoints(points)
plotLine(x, coeffs)
plt.show()
</script></div>
</div></div></article></div>
<article class="exercise exercise-like" id="exercise-44"><a data-knowl="" class="id-ref exercise-knowl original" data-refid="hk-exercise-44"><h6 class="heading">
<span class="type">Checkpoint</span><span class="space"> </span><span class="codenumber">3.24</span><span class="period">.</span>
</h6></a></article><div class="hidden-content tex2jax_ignore" id="hk-exercise-44"><article class="exercise exercise-like"><p id="p-205">Utilizando o método dos quadrados mínimos, ajuste uma função EXPONENCIAL aos pontos obtidos. Você pode inserir seus pontos e a função que encontrou no código abaixo para observá-los graficamente e calcular o erro associado ao ajuste.</p>
<div class="hidden-sagecell-sage" id="sage-36"><script type="text/x-sage">import numpy as np
import matplotlib.pyplot as plt

# Para observar sua solução graficamente, insira os coeficientes de sua função exponencial:
# f(x) = b*a^x
a =
b = 

points = 

def calcBoundaries(points):
    xMax = points[0][0]
    xMin =  points[0][0]
    yMax = points[0][1]
    yMin =  points[0][1]
    for point in points:
        if point[0] > xMax:
            xMax = point[0]
        if point[0] < xMin:
            xMin = point[0]
        if point[1] > yMax:
            yMax = point[1]
        if point[1] < yMin:
            yMin = point[1]

    plt.xlim(xMin-5, xMax+5) 
    plt.ylim(yMin-5, yMax+5)
    return (xMin-5, xMax+5)

def plotPoints(points):
    x = []
    y = []
    for point in points:
        x.append(point[0])
        y.append(point[1])
    
    plt.scatter(x, y, c='#000000')

def plotLine(x, coeffs):
    exponential = coeffs[0]*(coeffs[1]**x)
    plt.plot(x, exponential)

def calcError(points, coeffs):
    error = 0

    for point in points:
        error += (point[1] - (coeffs[0]*(coeffs[1]**point[0])))**2

    return np.round(error, 3)

boundaries = calcBoundaries(points)
x = np.arange(boundaries[0], boundaries[1], 0.001)
coeffs = [b, a]
plt.clf()
plotPoints(points)
plotLine(x, coeffs)
print(f'O erro associado é {calcError(points, coeffs)}')
plt.show()
</script></div>
<a data-knowl="" class="id-ref solution-knowl original" data-refid="hk-solution-13" id="solution-13"><span class="type">Solution.</span> </a><div class="hidden-content tex2jax_ignore" id="hk-solution-13"><div class="solution solution-like">
<p id="p-206">Utilize o código abaixo para conferir sua resposta. Observe o passo a passo da resolução. Lembre-se que os resultados \(c_1\) e \(c_2\) encontrados no vetor solução \(\hat{x}\) gera uma função exponencial da forma \(10^{c_{1} + c_{2}x}\)</p>
<div class="hidden-sagecell-sage" id="sage-37"><script type="text/x-sage">import numpy as np
import matplotlib.pyplot as plt 

points = 

def calcBoundaries(points):
    xMax = points[0][0]
    xMin =  points[0][0]
    yMax = points[0][1]
    yMin =  points[0][1]
    for point in points:
        if point[0] > xMax:
            xMax = point[0]
        if point[0] < xMin:
            xMin = point[0]
        if point[1] > yMax:
            yMax = point[1]
        if point[1] < yMin:
            yMin = point[1]

    plt.xlim(xMin-5, xMax+5)
    plt.ylim(yMin-5, yMax+5)
    return (xMin-5, xMax+5)

def plotPoints(points):
    x = []
    y = []
    for point in points:
        x.append(point[0])
        y.append(point[1])
    
    plt.scatter(x, y, c='#000000')

def plotLine(x, coeffs):
    exponential = coeffs[0]*(coeffs[1]**x)
    plt.plot(x, exponential)

def calcError(points, coeffs):
    error = 0

    for point in points:
        error += (point[1] - (coeffs[0]*(coeffs[1]**point[0])))**2

    return np.round(error, 3)

def normalEq(A, B):
    np.set_printoptions(formatter={'all':lambda x: str(np.round(x,2))})
    print("Escrevendo o sistema sobredeterminado na forma Ax = b, obtemos: ")
    print("A: ", end='')
    print(A)
    print("\nB: ", end='')
    print(B)

    At = np.transpose(A)
    AtAinv = np.dot(At, A)
    AtAinv = np.linalg.inv(AtAinv)
    sol = np.dot(np.dot(AtAinv, At), B)
    
    print("\nA matriz transposta de A é:")
    print(At)
    print("\nA matriz inversa do produto entre A^t e A é:")
    print(AtAinv)
    print("\nResolvendo a equação normal (A^t A)^(-1) * A^t * b, encontra-se a solução de mínimos quadrados x:")
    print(sol)
    return sol

def exponentialFit(points):
    A = []
    B = []

    for point in points:
        A.append([1, point[0]])
        B.append([np.log10(point[1])])

    A = np.array(A)
    B = np.array(B)
    sol = normalEq(A, B)

    expCoeffs = []
    expCoeffs.append(10**sol[0][0])
    expCoeffs.append(10**sol[1][0])

    print(f'\nA função exponencial que melhor se adapta aos pontos é: {np.round(expCoeffs[0],3)}*{np.round(expCoeffs[1],3)}^x')
    error = calcError(points, expCoeffs)
    print(f'O erro associado é igual a {error}')
    print("\nObservando a solução graficamente:")
    return expCoeffs

boundaries = calcBoundaries(points)
x = np.arange(boundaries[0], boundaries[1], 0.001)
coeffs = exponentialFit(points)
plt.clf()
plotPoints(points)
plotLine(x, coeffs)
plt.show()
</script></div>
</div></div></article></div>
<article class="exercise exercise-like" id="exercise-45"><a data-knowl="" class="id-ref exercise-knowl original" data-refid="hk-exercise-45"><h6 class="heading">
<span class="type">Checkpoint</span><span class="space"> </span><span class="codenumber">3.25</span><span class="period">.</span>
</h6></a></article><div class="hidden-content tex2jax_ignore" id="hk-exercise-45"><article class="exercise exercise-like"><p id="p-207">Com as 4 curvas encontradas, reflita: Qual é a que melhor se ajusta ao conjunto de pontos que você gerou?</p>
<a data-knowl="" class="id-ref solution-knowl original" data-refid="hk-solution-14" id="solution-14"><span class="type">Solution.</span> </a><div class="hidden-content tex2jax_ignore" id="hk-solution-14"><div class="solution solution-like">
<p id="p-208">Insira seus pontos no código abaixo para ver a comparação entre as 4 curvas.</p>
<div class="hidden-sagecell-sage" id="sage-38"><script type="text/x-sage">import numpy as np
import matplotlib.pyplot as plt
import matplotlib.lines as lines

points = 

def calcBoundaries(points):
    xMax = points[0][0]
    xMin =  points[0][0]
    yMax = points[0][1]
    yMin =  points[0][1]
    for point in points:
        if point[0] > xMax:
            xMax = point[0]
        if point[0] < xMin:
            xMin = point[0]
        if point[1] > yMax:
            yMax = point[1]
        if point[1] < yMin:
            yMin = point[1]

    plt.xlim(xMin-5, xMax+5) 
    plt.ylim(yMin-5, yMax+5)
    return (xMin-5, xMax+5)

def setLabels():
    legendElements = [lines.Line2D([0], [0], color='green', lw=4, label='Linear'),
                    lines.Line2D([0], [0], color='blue', lw=4, label='Quadrática'),
                    lines.Line2D([0], [0], color='red', lw=4, label='Cúbica'),
                    lines.Line2D([0], [0], color='orange', lw=4, label='Exponencial')]
    
    plt.legend(handles=legendElements)

def plotPoints(points):
    x = []
    y = []
    for point in points:
        x.append(point[0])
        y.append(point[1])
    
    plt.scatter(x, y, c='#000000')

def PolyCoefficients(x, coeffs):
    o = len(coeffs)
    y = 0
    for i in range(o):
        y += coeffs[i]*x**i
    return y

def plotLine(x, coeffs):
    colours = ['green', 'blue', 'red']
    polynomial = PolyCoefficients(x, coeffs)
    plt.plot(x, polynomial, c=colours[len(coeffs)-2])

def plotLineExp(x, coeffs):
    exponential = coeffs[0]*(coeffs[1]**x)
    plt.plot(x, exponential, c='orange')

def normalEq(A, B):
    np.set_printoptions(formatter={'all':lambda x: str(x)})
    At = np.transpose(A)
    AtAinv = np.dot(At, A)
    AtAinv = np.linalg.inv(AtAinv)
    sol = np.dot(np.dot(AtAinv, At), B)

    return sol

def calcErrorPoly(points, coeffs):
    error = 0
    o = len(coeffs)

    for point in points:
        y = 0
        for i in range(o):
            y += coeffs[i][0]*point[0]**i

        error += ((point[1] - y)**2)

    return np.round(error, 3)

def calcErrorExp(points, coeffs):
    error = 0

    for point in points:
        error += (point[1] - (coeffs[0]*(coeffs[1]**point[0])))**2

    return np.round(error, 3)

def linearFit(points):
    A = []
    B = []

    for point in points:
        A.append([1, point[0]])
        B.append([point[1]])

    A = np.array(A)
    B = np.array(B)
    sol = normalEq(A, B)

    print(f'\nA função linear que melhor se adapta aos pontos é: {np.round(sol[0][0],3)} + ({np.round(sol[1][0], 3)})x')
    error = calcErrorPoly(points, sol)
    print(f'O erro associado é igual a {error}')
    return sol

def quadraticFit(points):
    A = []
    B = []

    for point in points:
        A.append([1, point[0], point[0]**2])
        B.append([point[1]])

    A = np.array(A)
    B = np.array(B)
    sol = normalEq(A, B)

    print(f'\nA função quadratica que melhor se adapta aos pontos é: {np.round(sol[0][0],3)} + ({np.round(sol[1][0], 3)})x + ({np.round(sol[2][0], 3)})x^2')
    error = calcErrorPoly(points, sol)
    print(f'O erro associado é igual a {error}')
    return sol

def cubicFit(points):
    A = []
    B = []

    for point in points:
        A.append([1, point[0], point[0]**2, point[0]**3])
        B.append([point[1]])

    A = np.array(A)
    B = np.array(B)
    sol = normalEq(A, B)

    print(f'\nA função cubica que melhor se adapta aos pontos é: {np.round(sol[0][0],3)} + ({np.round(sol[1][0], 3)})x + ({np.round(sol[2][0], 3)})x^2 + ({np.round(sol[3][0], 3)})x^3')
    error = calcErrorPoly(points, sol)
    print(f'O erro associado é igual a {error}')
    return sol

def exponentialFit(points):
    A = []
    B = []

    for point in points:
        A.append([1, point[0]])
        B.append([np.log10(point[1])])

    A = np.array(A)
    B = np.array(B)
    sol = normalEq(A, B)

    expCoeffs = []
    expCoeffs.append(10**sol[0][0])
    expCoeffs.append(10**sol[1][0])

    print(f'\nA função exponencial que melhor se adapta aos pontos é: {np.round(expCoeffs[0],3)}*{np.round(expCoeffs[1],3)}^x')
    error = calcErrorExp(points, expCoeffs)
    print(f'O erro associado é igual a {error}')
    return expCoeffs

plt.clf()
boundaries = calcBoundaries(points)
x = np.arange(boundaries[0], boundaries[1], 0.001)
linCoeffs = linearFit(points)
quadCoeffs = quadraticFit(points)
cubicCoeffs = cubicFit(points)
expCoeffs = exponentialFit(points)
plotPoints(points)
plotLine(x, linCoeffs)
plotLine(x, quadCoeffs)
plotLine(x, cubicCoeffs)
plotLineExp(x, expCoeffs)
setLabels()
plt.show()
</script></div>
</div></div></article></div></section><section class="subsection" id="Proj4"><h3 class="heading hide-type">
<span class="type">Subsection</span> <span class="codenumber">3.4</span> <span class="title">Projeto 4 - Metrologia coordenada</span>
</h3>
<p id="p-209">Em diversos processos de fabricação, o controle de qualidade é realizado com auxílio de sensores que detectam pontos do perímetro da peça produzida e comparam estes pontos com o perímetro teórico do objeto.</p>
<p id="p-210">Neste projeto, suponha que você calculará o fator de erro de cada peça fabricada por uma máquina. As peças devem ter, em teoria, formato circular. Para isso, você deve encontrar, utilizando o método dos quadrados mínimos, a equação da circunferência que melhor se ajusta aos pontos gerados.</p>
<article class="remark remark-like" id="remark-16"><h6 class="heading">
<span class="type">Remark</span><span class="space"> </span><span class="codenumber">3.26</span><span class="period">.</span>
</h6>Execute o código abaixo para obter os pontos detectados no perímetro da peça fabricada. Não altere os valores de RAIO_MAX e N_PONTOS <div class="sagecell-sage" id="sage-39"><script type="text/x-sage">import random as rd
import numpy as np
import matplotlib.pyplot as plt

RAIO_MAX = 20
N_PONTOS = 10

def randomPoint(xMin, xMax, rMin, rMax):
    sign = rd.randrange(0,2)
    randRadius = rd.randrange(rMin, rMax) + rd.random()
    x = rd.randrange(xMin, xMax) + rd.random()

    while randRadius **2 - x**2 < 0:
        x = rd.randrange(xMin, xMax) + rd.random()

    y = np.sqrt(randRadius**2 - x**2)
    x = round(x, 2)

    if sign == 1:
        y = round(y, 2)
    else:
        y = round(-y, 2)

    return (x,y)

def generatePoints(totalPoints, rMin, rMax):
    points = []
    xMin = -rMax
    xMax = rMax
    step = (xMax - xMin)/totalPoints

    for i in range(totalPoints):
        infLimitx = xMin + step*i
        supLimitx = xMin + step*(i+1)
        points.append(randomPoint(infLimitx, supLimitx, rMin, rMax))

    return points

def printPoints(points):
    print("Os pontos gerados são:")
    for point in points:
        print(point)
    print("\n Para copiar e colar nos codigos seguintes:")
    print("points = ", end='')
    print(points)

def plotPoints(points, rMax):
    plt.clf()
    x = []
    y = []
    for point in points:
        x.append(point[0])
        y.append(point[1])

    plt.gca().set_aspect('equal')
    plt.xlim(-(rMax+rMax/10), (rMax+rMax/10))
    plt.ylim(-(rMax+rMax/10), (rMax+rMax/10))
    plt.scatter(x, y, c='#000000')


points = generatePoints(N_PONTOS, RAIO_MAX - np.round(RAIO_MAX/10), RAIO_MAX)
printPoints(points)
plt.clf()
plotPoints(points, RAIO_MAX)
plt.show()
</script></div></article><article class="exercise exercise-like" id="exercise-46"><a data-knowl="" class="id-ref exercise-knowl original" data-refid="hk-exercise-46"><h6 class="heading">
<span class="type">Checkpoint</span><span class="space"> </span><span class="codenumber">3.27</span><span class="period">.</span>
</h6></a></article><div class="hidden-content tex2jax_ignore" id="hk-exercise-46"><article class="exercise exercise-like"><p id="p-211">Encontre o raio e o centro da circunferência que melhor se ajusta aos pontos obtidos. Dica: Monte um sistema com 3 incógnitas</p>
<p id="p-212">Você pode utilizar o código abaixo para observar graficamente a circunferencia obtida:</p>
<div class="hidden-sagecell-sage" id="sage-40"><script type="text/x-sage">import numpy as np
import matplotlib.pyplot as plt

# insira as coordenadas do centro do círculo e seu raio
centro = ( , )
raio = 

points = 

def setBoundaries(radius, x0, y0):
    plt.xlim(-radius+x0-5, radius+x0+5)
    plt.ylim(-radius+y0-5, radius+y0+5)

def plotPoints(points):
    x = []
    y = []
    for point in points:
        x.append(point[0])
        y.append(point[1])
    
    plt.gca().set_aspect('equal')
    plt.scatter(x, y, c='#000000')

def plotLine(radius, x0, y0):
    theta = np.linspace(0, 2*np.pi, 1000)
    x1 = x0+radius*np.cos(theta)
    x2 = y0+radius*np.sin(theta)
    plt.plot(x1, x2)

plt.clf()
plotPoints(points)
plotLine(raio, centro[0], centro[1])
setBoundaries(raio, centro[0], centro[1])
plt.show()
</script></div>
<a data-knowl="" class="id-ref solution-knowl original" data-refid="hk-solution-15" id="solution-15"><span class="type">Solution.</span> </a><div class="hidden-content tex2jax_ignore" id="hk-solution-15"><div class="solution solution-like">
<p id="p-213">A circunferência com centro em \((c_{1}, c_{2})\) é descrita por \((x-c_{1})^{2} + (y-c_{2})^{2} = R^{2}\text{.}\) Assim:</p>
<div class="displaymath">
\begin{gather*}
(x-c_{1})^{2} + (y-c_{2})^{2} = R^{2} \\
\implies 2xc_{1} + 2yc_{2} + (R^{2} - c_{1}^{2} - c_{2}^{2}) = x^{2} + y^{2}\\
(R^{2} - c_{1}^{2} - c_{2}^{2}) = c_3 \\
\implies 2xc_1 + 2yc_2 + c_3 = x^{2} + y^{2} 
\end{gather*}
</div>
<p id="p-214">Os valores de x e y são conhecidos (utilizar as coordenadas dos pontos obtidos). Basta montar o sistema para \(c_1\text{,}\) \(c_2\) e \(c_3\) com \(N\) equações, onde \(N\) é o número de pontos detectados pelo sensor.</p>
</div></div></article></div>
<article class="exercise exercise-like" id="exercise-47"><a data-knowl="" class="id-ref exercise-knowl original" data-refid="hk-exercise-47"><h6 class="heading">
<span class="type">Checkpoint</span><span class="space"> </span><span class="codenumber">3.28</span><span class="period">.</span>
</h6></a></article><div class="hidden-content tex2jax_ignore" id="hk-exercise-47"><article class="exercise exercise-like"><p id="p-215">Agora encontre o erro associado à fabricação da peça. O erro pode ser descrito como a soma dos módulos de cada vetor \(r\) associado a cada ponto detectado. \(r = R - dist(P, C)\) onde \(P\) é cada ponto que o sensor detectou no perímetro da peça e \(C\) é o centro da circunferência obtida por você. O erro pode ser tomado como uma medida de "quão circular" é o conjunto de pontos.</p>
<a data-knowl="" class="id-ref solution-knowl original" data-refid="hk-solution-16" id="solution-16"><span class="type">Solution.</span> </a><div class="hidden-content tex2jax_ignore" id="hk-solution-16"><div class="solution solution-like">
<p id="p-216">Utilize o código abaixo para encontrar o erro associado ao ajuste por quadrados mínimos:</p>
<div class="hidden-sagecell-sage" id="sage-41"><script type="text/x-sage">import numpy as np

# Insira as coordenadas do centro do círculo e seu raio
centro = ( , )
raio =

points = 

def calcError(points, coeffs, raio):
    error = 0
    radius = raio

    for point in points:
        error += np.sqrt((radius - np.sqrt((point[0]-coeffs[0])**2 + (point[1]-coeffs[1])**2))**2)

    return np.round(error, 3)

print(f'O erro associado é {calcError(points, centro, raio)}')
</script></div>
</div></div></article></div>
<article class="exercise exercise-like" id="exercise-48"><a data-knowl="" class="id-ref exercise-knowl original" data-refid="hk-exercise-48"><h6 class="heading">
<span class="type">Checkpoint</span><span class="space"> </span><span class="codenumber">3.29</span><span class="period">.</span>
</h6></a></article><div class="hidden-content tex2jax_ignore" id="hk-exercise-48"><article class="exercise exercise-like"><p id="p-217">Utilize o código abaixo para conferir suas respostas. Observe o passo a passo da solução.</p>
<div class="hidden-sagecell-sage" id="sage-42"><script type="text/x-sage">import numpy as np
import matplotlib.pyplot as plt

points = 

def setBoundaries(radius, x0, y0):
    plt.xlim(-radius+x0-5, radius+x0+5)
    plt.ylim(-radius+y0-5, radius+y0+5)

def plotPoints(points):
    x = []
    y = []
    for point in points:
        x.append(point[0])
        y.append(point[1])
    
    plt.gca().set_aspect('equal')
    plt.scatter(x, y, c='#000000')

def plotLine(radius, x0, y0):
    theta = np.linspace(0, 2*np.pi, 1000)
    x1 = x0+radius*np.cos(theta)
    x2 = y0+radius*np.sin(theta)
    plt.plot(x1, x2)

def calcError(points, coeffs):
    error = 0
    radius = np.sqrt(coeffs[2][0] + coeffs[0][0]**2 + coeffs[1][0]**2)

    for point in points:
        error += np.sqrt((radius - np.sqrt((point[0]-coeffs[0][0])**2 + (point[1]-coeffs[1][0])**2))**2)

    return np.round(error, 3)

def normalEq(A, B):
    np.set_printoptions(formatter={'all':lambda x: str(np.round(x,2))})
    print("Escrevendo o sistema sobredeterminado na forma Ax = b, obtemos: ")
    print("A: ", end='')
    print(A)
    print("\nB: ", end='')
    print(B)

    At = np.transpose(A)
    AtAinv = np.dot(At, A)
    AtAinv = np.linalg.inv(AtAinv)
    sol = np.dot(np.dot(AtAinv, At), B)
    
    print("\nA matriz transposta de A é:")
    print(At)
    print("\nA matriz inversa do produto entre A^t e A é:")
    print(AtAinv)
    print("\nResolvendo a equação normal (A^t A)^(-1) * A^t * b, encontra-se a solução de mínimos quadrados x:")
    print(sol)
    return sol

def circleFit(points):
    A = []
    B = []

    for point in points:
        A.append([2*point[0], 2*point[1], 1])
        B.append([point[0]**2 + point[1]**2])

    A = np.array(A)
    B = np.array(B)
    sol = normalEq(A, B)
    radius = np.sqrt(sol[2][0] + sol[0][0]**2 + sol[1][0]**2)

    print(f'\nO centro do circulo que melhor descreve os pontos é ({np.round(sol[0][0],3)}, {np.round(sol[1][0], 3)}). \n O raio do circulo é {np.round(radius, 3)}.')
    error = calcError(points, sol)
    print(f'O erro associado é igual a {error}')
    print("\nObservando a solução graficamente:")
    return (radius, sol[0][0], sol[1][0])

fit = circleFit(points)
radius = fit[0]
x0  = fit[1]
y0 = fit[2]

plt.clf()
plotPoints(points)
plotLine(radius, x0, y0)
setBoundaries(radius, x0, y0)
plt.show()
</script></div></article></div></section><section class="subsection" id="Proj5"><h3 class="heading hide-type">
<span class="type">Subsection</span> <span class="codenumber">3.5</span> <span class="title">Projeto 5 - Compressão de imagens quadradas com autovalores e autovetores</span>
</h3>
<p id="p-218">Em um computador, uma imagem (em preto e branco) é representada por uma matriz, onde cada valor representa um pixel, isto é, um ponto da imagem. Este valor pode ir de 0 (preto) a 255 (branco). Imagens coloridas são representadas por três matrizes: Uma referente ao canal vermelho (R), outra referente ao canal verde (G) e outra referente ao canal azul (B). Da mesma forma, quando um pixel é representado pelo valor 0 nas três matrizes, temos a cor preta. Quando o pixel é representado pelo valor 255 nas três matrizes, temos a cor branca. Valores intermediários representam ponderações de vermelho, verde e azul, de modo a formar todas as outras cores possíveis. Para transformar uma imagem colorida em uma imagem preta e branca, basta fazer uma média simples entre os elementos \(a_{ij}\) das matrizes R, G e B.</p>
<p id="p-219">Ao representarmos imagens quadradas como matrizes, podemos extrair seus autovalores e autovetores, obtendo uma base de autovetores para o espaço coluna da matriz da imagem. Neste projeto, será abordado o processo de compressão de imagens utiizando estas características.</p>
<article class="exercise exercise-like" id="exercise-49"><a data-knowl="" class="id-ref exercise-knowl original" data-refid="hk-exercise-49"><h6 class="heading">
<span class="type">Checkpoint</span><span class="space"> </span><span class="codenumber">3.30</span><span class="period">.</span>
</h6></a></article><div class="hidden-content tex2jax_ignore" id="hk-exercise-49"><article class="exercise exercise-like"><p id="p-220">Procure uma <dfn class="terminology">imagem quadrada</dfn> (e. g. 1080 x 1080, 400 x 400) qualquer para ver sua representação em três canais. Você deve fornecer ao programa o link de uma imagem.</p>
<p id="p-221">Observação: Devido a uma trava existente no SageMath (recurso utilizado para executar os códigos no site), o programa não consegue se comunicar com a maioria dos sites. Sabe-se que quaisquer links de imagens da wikipedia (wikimedia) conseguem ser acessados para obter a imagem. Portanto, utilize alguma imagem proveniente de <a class="external" href="" target="_blank">https://commons.wikimedia.org/wiki/Category:Square_images</a>. Se você decidir executar o código diretamente em sua máquina, qualquer link, independente do site de origem, funcionará.</p>
<div class="hidden-sagecell-sage" id="sage-43"><script type="text/x-sage">import requests
import numpy as np
import matplotlib.pyplot as plt
from skimage import color
from skimage import io

#Coloque o link da sua imagem aqui!
url = "https://upload.wikimedia.org/wikipedia/commons/5/50/Bing_AI_image_of_a_19th-century_brakeman_swinging_a_lantern_to_stop_an_approaching_train_in_a_rock_cut_on_a_winter_night.jpeg"

# Função que faz a conexão com a URL e retorna a resposta
def getFromUrl(url):
    img = io.imread(url)
    if img.shape[0] != img.shape[1]:
        raise Exception("A imagem deve ser quadrada!")
    return img

# Funções que separa os canais RGB da imagem
def getRedChannel(img):
    dataR = img.copy()
    dataR[:,:,1] =0 
    dataR[:,:,2] =0
    return dataR

def getGreenChannel(img):
    dataG = img.copy()
    dataG[:,:,0] =0 
    dataG[:,:,2] =0
    return dataG

def getBlueChannel(img):
    dataB = img.copy()
    dataB[:,:,0] =0 
    dataB[:,:,1] =0
    return dataB

# Função que transforma a imagem em preto e branco
def getGreyImage(img):
    dataPB = []
    for i in range(np.shape(img)[0]):
        dataPB.append([])
        for j in range(np.shape(img)[1]):
            dataPB[i].append(np.mean(img[i][j]))
    return np.array(dataPB)

# Chamam-se as funções para pegar a imagem e extrair seus canais
img = getFromUrl(url)
imgR = getRedChannel(img)
imgG = getGreenChannel(img)
imgB = getBlueChannel(img)
imgGrey = getGreyImage(img)

print("A imagem original é:")
plt.imshow(img)
plt.show()
plt.clf()
print("O canal R (vermelho) da imagem é dado por:")
plt.imshow(imgR)
plt.show()
plt.clf()
print("O canal G (verde) da imagem é dado por:")
plt.imshow(imgG)
plt.show()
plt.clf()
print("O canal B (azul) da imagem é dado por:")
plt.imshow(imgB)
plt.show()
plt.clf()
print("Fazendo uma média entre os três canais, obtem-se uma imagem em preto e branco:")
plt.imshow(imgGrey, cmap='gray')
plt.show()
plt.clf()
</script></div></article></div>
<article class="remark remark-like" id="remark-17"><h6 class="heading">
<span class="type">Remark</span><span class="space"> </span><span class="codenumber">3.31</span><span class="period">.</span>
</h6>
<p id="p-222">Agora, iremos analisar os autovalores e autovetores associados à matriz da imagem em preto e branco para realizar uma decomposição \(A=PDP^{-1}\text{.}\)</p></article><article class="exercise exercise-like" id="exercise-50"><a data-knowl="" class="id-ref exercise-knowl original" data-refid="hk-exercise-50"><h6 class="heading">
<span class="type">Checkpoint</span><span class="space"> </span><span class="codenumber">3.32</span><span class="period">.</span>
</h6></a></article><div class="hidden-content tex2jax_ignore" id="hk-exercise-50"><article class="exercise exercise-like"><p id="p-223">O programa a seguir extrai os autovalores da imagem em preto e branco e os coloca em ordem decrescente de magnitude (norma ou tamanho). Você pode observar graficamente o módulo de cada autovalor, bem como o peso acumulado (soma dos módulos dos primeiros autovalores de 0 a \(n\) dividida pela soma de todos os autovalores). Com base nisso indique, justificando a sua resposta: quantos dos primeiros autovalores você precisaria manter para obter 20% da qualidade da imagem? E 50%? E 90%? Justifique suas respostas.</p>
<div class="hidden-sagecell-sage" id="sage-44"><script type="text/x-sage">import requests
import numpy as np
import matplotlib.pyplot as plt
from skimage import color
from skimage import io

#Coloque o link da sua imagem aqui!
url = "https://upload.wikimedia.org/wikipedia/commons/5/50/Bing_AI_image_of_a_19th-century_brakeman_swinging_a_lantern_to_stop_an_approaching_train_in_a_rock_cut_on_a_winter_night.jpeg"

# Função que faz a conexão com a URL e retorna a resposta
def getFromUrl(url):
    img = io.imread(url)
    if img.shape[0] != img.shape[1]:
        raise Exception("A imagem deve ser quadrada!")
    return img

# Função que transforma a imagem em preto e branco
def getGreyImage(img):
    dataPB = []
    for i in range(np.shape(img)[0]):
        dataPB.append([])
        for j in range(np.shape(img)[1]):
            dataPB[i].append(np.mean(img[i][j]))
    return np.array(dataPB)

# Obtemos os autovalores e autovetores da matriz da imagem em preto e branco
def getEigValuesAndVectors(dataPB):
    eigValues, eigVectors = np.linalg.eig(dataPB)
    return eigValues, eigVectors

# Obtemos a norma dos autovalores e os ordenamos em ordem decrescente
def eigSort(eigValues, eigVectors):
    eValNorm = []
    for i in range(len(eigValues)):
        eValNorm.append(np.linalg.norm(eigValues[i]))
    eValNorm = np.array(eValNorm)
    idx = eValNorm.argsort()[::-1]
    sortedEVal = eigValues[idx]
    sortedEVec = eigVectors[:,idx]
    return eValNorm, sortedEVal, sortedEVec

def accumulatedWeight(eigValues):
    weight = np.sum(eigValues)
    n = len(eigValues)
    triangular = np.tril(np.ones((n, n), dtype=int)).transpose()
    accumWeight = eigValues.dot(triangular)/weight
    return accumWeight

img = getFromUrl(url)
imgGrey = getGreyImage(img)

# Chama-se as funções para obter os autovalores e autovetores ordenados da imagem em preto e branco
sortedEVNorms, sortedEigValues, sortedEigVectors = eigSort(*getEigValuesAndVectors(imgGrey))

# Chama-se a função para obter o peso acumulado de autovalores
accumWeight = accumulatedWeight(sortedEVNorms)

print(f"A matriz que representa a imagem {len(sortedEVNorms)}x{len(sortedEVNorms)} possui {len(sortedEVNorms)} autovalores.")
print("Aqui estão os autovalores ordenados da matriz da imagem em preto e branco:")
plt.xlabel("Posição do autovalor")
plt.ylabel("Módulo do autovalor")
plt.scatter(range(1, len(sortedEVNorms)+1), sortedEVNorms)
plt.show()
plt.clf()
print("Aqui estão os autovalores ordenados em escala logaritmica:")
plt.xlabel("Posição do autovalor")
plt.ylabel("Módulo do autovalor")
plt.yscale("log")
plt.scatter(range(1, len(sortedEVNorms)+1), sortedEVNorms)
plt.show()
plt.clf()
print("Aqui está o peso acumulado (soma dos autovalores de 0 até x):")
plt.xlabel("Quantidade de autovalores")
plt.ylabel("Peso acumulado")
plt.plot(range(1, len(accumWeight) + 1), accumWeight)
plt.show()
plt.clf()
</script></div>
<a data-knowl="" class="id-ref solution-knowl original" data-refid="hk-solution-17" id="solution-17"><span class="type">Solution.</span> </a><div class="hidden-content tex2jax_ignore" id="hk-solution-17"><div class="solution solution-like">Observe que uma boa parte dos autovalores é insignificante se comparada à soma dos módulos de todos os autovalores. Esse conjunto de valores pequenos pode ser descartado sem grandes perdas de qualidade na imagem, mas com significativo impacto em seu tamanho no armazenamento.</div></div></article></div>
<p id="p-224">Na decomposição \(PDP^{-1}\text{,}\) multilplica-se a matriz \(P\text{,}\) cujas colunas são os autovetores de \(A\text{,}\) pela matriz diagonal \(D\text{,}\) que contem os autovalores da matriz em sua diagonal principal. O produto é, então, multiplicado por \(P^{-1}\text{.}\) Pode-se interpretar o produto \(PD\) como a operação de "esticar" cada autovetor através da multiplicação por seu autovalor correspondente. Nesse contexto, autovalores muito próximos de 0 tem um efeito quase insignificante na matriz final \(A\text{,}\) e por isso, podemos descartá-los, bem como os autovetores associados a eles.</p>
<p id="p-225">Este processo pode ser usado para comprimir imagens, eliminando uma quantidade significativa da memória utilizada para armazená-la.</p>
<p id="p-226">Manter apenas os \(r\) autovalores mais significativos da matriz \(A_{n\times n}\) significa remover as colunas \(r+1, r+2, \ldots, n\) da matriz \(P\text{,}\) obtendo uma matriz \(n \times r\text{.}\) Para a matriz \(D\) mantemos apenas as primeiras \(r\) linhas e as primeiras \(r \) colunas, obtendo uma matriz \(r \times r\text{.}\) Para a matriz \(P^{-1}\) mantemos apenas as primeiras \(r\) linhas, obtendo uma matriz \(r \times n\text{.}\)</p>
<article class="exercise exercise-like" id="exercise-51"><a data-knowl="" class="id-ref exercise-knowl original" data-refid="hk-exercise-51"><h6 class="heading">
<span class="type">Checkpoint</span><span class="space"> </span><span class="codenumber">3.33</span><span class="period">.</span>
</h6></a></article><div class="hidden-content tex2jax_ignore" id="hk-exercise-51"><article class="exercise exercise-like"><p id="p-227">Agora, execute o código abaixo para visualizar a imagem compactada gerada ao utilizar a decomposição \(PDP^{-1}\) mantendo apenas os primeiros \(r\) autovalores, para os valores escolhidos no checkpoint anterior. Os resultados corresponde ao que você esparava?</p>
<div class="hidden-sagecell-sage" id="sage-45"><script type="text/x-sage">import requests
import numpy as np
import matplotlib.pyplot as plt
from skimage import color
from skimage import io
from PIL import Image

url = "https://upload.wikimedia.org/wikipedia/commons/5/50/Bing_AI_image_of_a_19th-century_brakeman_swinging_a_lantern_to_stop_an_approaching_train_in_a_rock_cut_on_a_winter_night.jpeg"
nAutovalores = 50

# Função que faz a conexão com a URL e retorna a resposta
def getFromUrl(url):
    img = io.imread(url)
    if img.shape[0] != img.shape[1]:
        raise Exception("A imagem deve ser quadrada!")
    return img

# Função que transforma a imagem em preto e branco
def getGreyImage(img):
    dataPB = []
    for i in range(np.shape(img)[0]):
        dataPB.append([])
        for j in range(np.shape(img)[1]):
            dataPB[i].append(np.mean(img[i][j]))
    return np.array(dataPB)

# Obtemos os autovalores e autovetores da matriz da imagem em preto e branco
def getEigValuesAndVectors(dataPB):
    eigValues, eigVectors = np.linalg.eig(dataPB)
    return eigValues, eigVectors

# Obtemos a norma dos autovalores e os ordenamos em ordem decrescente
def eigSort(eigValues, eigVectors):
    eValNorm = []
    for i in range(len(eigValues)):
        eValNorm.append(np.linalg.norm(eigValues[i]))
    eValNorm = np.array(eValNorm)
    idx = eValNorm.argsort()[::-1]
    sortedEVal = eigValues[idx]
    sortedEVec = eigVectors[:,idx]
    return eValNorm, sortedEVal, sortedEVec

# Chamam-se as funções para pegar a imagem e extrair seus canais
img = getFromUrl(url)
imgGrey = getGreyImage(img)

# Chamam-se as funções para obter os autovalores e autovetores ordenados da imagem em preto e branco
sortedEVNorms, sortedEigValues, sortedEigVectors = eigSort(*getEigValuesAndVectors(imgGrey))

# Selecionamos os autovetores associados aos nAutovalores escolhidos e criamos as matrizes PDP^-1
P = sortedEigVectors
D = np.diag(sortedEigValues[:nAutovalores])
invP = np.linalg.inv(P)
P = P[:, :nAutovalores]
invP = invP[:nAutovalores, :]
newImg = np.dot(np.dot(P, D), invP)

print("A imagem original é:")
plt.imshow(imgGrey, cmap='gray')
plt.show()
plt.clf()
print("A imagem compactada é:")
plt.imshow(Image.fromarray(newImg.real, cmap='gray'))
plt.show()
plt.clf()
</script></div></article></div>
<article class="exercise exercise-like" id="exercise-52"><a data-knowl="" class="id-ref exercise-knowl original" data-refid="hk-exercise-52"><h6 class="heading">
<span class="type">Checkpoint</span><span class="space"> </span><span class="codenumber">3.34</span><span class="period">.</span>
</h6></a></article><div class="hidden-content tex2jax_ignore" id="hk-exercise-52"><article class="exercise exercise-like"><p id="p-228">Quantas números a matriz da foto original em escala cinza continha? Quantos números têm as matrizes obtidas mantendo apenas \(r\) autovalores para cada um dos três casos que escolheu utilizar? Qual a economia de espaço obtida em cada um dos casos?</p></article></div></section><section class="subsection" id="Proj6"><h3 class="heading hide-type">
<span class="type">Subsection</span> <span class="codenumber">3.6</span> <span class="title">Projeto 6 - Compressão de imagens retangulares utilizando SVD</span>
</h3>
<p id="p-229">No projeto 5 foi abordada a compressão de imagens quadradas utilizando autovalores e autovetores através da decomposição \(PDP^{-1}\text{.}\) Seria possível realizar uma operação similar para imagens retangulares, representadas por matrizes não quadradas, uma vez que estas não admitem autovalores e autovetores? A resposta é sim! Isto é possível graças a uma técnica amplamente utilizada em processamento digital de imagens: a Decomposição em valores singulares, ou SVD (sigla em ingês).</p>
<article class="remark remark-like" id="remark-18"><h6 class="heading">
<span class="type">Remark</span><span class="space"> </span><span class="codenumber">3.35</span><span class="period">.</span>
</h6>
<p id="p-230">Para decompor uma matriz \(A_{m\times n}\text{,}\) \(m &gt; n\text{,}\) utilizando SVD, precisamos primeiro calcular duas matrizes: \(AA^T\text{,}\) de ordem \(m\times m\) e \(A^TA\text{,}\) de ordem \(n\times n\)</p>
<p id="p-231">Observe que estas duas matrizes são simétricas, e portanto possuem \(m\) e \(n\) autovalores reais e distintos, respectivamente. Se ordenarmos estes autovalores, os correspondentes de cada matriz serão iguais, isto é, o autovalor mais significativo de \(A^TA\) é igual ao autovalor mais significativo de \(AA^T\text{,}\) assim como o segundo autovalor mais significativo de cada matriz, e assim em diante.</p>
<p id="p-232">Definem-se, então, as matrizes \(U\) e \(V\text{:}\)</p>
<ol class="decimal">
<li id="li-120"><p id="p-derived-li-120">\(U\) é a matriz \(m\times m\) cujas colunas são os autovetores de \(AA^T\)</p></li>
<li id="li-121"><p id="p-derived-li-121">\(V\) é a matriz \(n\times n\) cujas colunas são os autovetores de \(A^TA\)</p></li>
</ol>
<p id="p-233">Por fim, define-se uma matriz \(\Sigma _{m\times n}\text{:}\)</p>
<div class="displaymath">
\begin{equation*}
\Sigma _{m\times n} = \begin{pmatrix}
\sigma_1 \amp 0 \amp 0 \amp \cdots \amp 0 \\
0 \amp \sigma_1 \amp 0 \amp \cdots \amp 0 \\
\vdots \amp \vdots \amp \ddots \amp \cdots \amp \vdots \\
0 \amp 0 \amp 0 \amp \cdots \amp \sigma_n \\
\vdots \amp \vdots \amp \ddots \amp \cdots \amp \vdots \\    
0 \amp 0 \amp 0 \amp \cdots \amp 0      
\end{pmatrix}
\end{equation*}
</div>
<p id="p-234">Onde cada \(\sigma_i\) é um valor singular de \(A^TA\text{,}\) de modo que \(\sigma_i = \sqrt{\lambda_i}\text{.}\)</p>
<p id="p-235">Em linhas gerais, \(\Sigma_m\times n\) é uma matriz cujas \(n\) primeiras linhas correspondem a uma matriz diagonal com os valores singulares em sua diagonal principal. Suas \(m-n\) linhas restantes contém somente zeros.</p>
<p id="p-236">Assim sendo, temos a decomposição em valores singulares de \(A\) como:</p>
<div class="displaymath">
\begin{equation*}
A=U\Sigma V^T
\end{equation*}
</div></article></section></section></div></main>
</div>
</body>
</html>
